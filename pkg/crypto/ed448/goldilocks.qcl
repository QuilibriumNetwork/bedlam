package ed448

import (
	"bits"
	"crypto/subtle"
	"encoding/binary"
)

// Elt is a prime field element.
type Elt [56]byte

// genX is the x-coordinate of the generator of Goldilocks curve.
var genX = Elt{
	0x5e, 0xc0, 0x0c, 0xc7, 0x2b, 0xa8, 0x26, 0x26,
	0x8e, 0x93, 0x00, 0x8b, 0xe1, 0x80, 0x3b, 0x43,
	0x11, 0x65, 0xb6, 0x2a, 0xf7, 0x1a, 0xae, 0x12,
	0x64, 0xa4, 0xd3, 0xa3, 0x24, 0xe3, 0x6d, 0xea,
	0x67, 0x17, 0x0f, 0x47, 0x70, 0x65, 0x14, 0x9e,
	0xda, 0x36, 0xbf, 0x22, 0xa6, 0x15, 0x1d, 0x22,
	0xed, 0x0d, 0xed, 0x6b, 0xc6, 0x70, 0x19, 0x4f,
}

// genY is the y-coordinate of the generator of Goldilocks curve.
var genY = Elt{
	0x14, 0xfa, 0x30, 0xf2, 0x5b, 0x79, 0x08, 0x98,
	0xad, 0xc8, 0xd7, 0x4e, 0x2c, 0x13, 0xbd, 0xfd,
	0xc4, 0x39, 0x7c, 0xe6, 0x1c, 0xff, 0xd3, 0x3a,
	0xd7, 0xc2, 0xa0, 0x05, 0x1e, 0x9c, 0x78, 0x87,
	0x40, 0x98, 0xa3, 0x6c, 0x73, 0x73, 0xea, 0x4b,
	0x62, 0xc7, 0xc9, 0x56, 0x37, 0x20, 0x76, 0x88,
	0x24, 0xbc, 0xb6, 0x6e, 0x71, 0x46, 0x3f, 0x69,
}

// paramD is -39081 in
var paramD = Elt{
	0x56, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

// order is 2^446-0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d,
// which is the number of points in the prime subgroup.
var order = Scalar{
	0xf3, 0x44, 0x58, 0xab, 0x92, 0xc2, 0x78, 0x23,
	0x55, 0x8f, 0xc5, 0x8d, 0x72, 0xc2, 0x6c, 0x21,
	0x90, 0x36, 0xd6, 0xae, 0x49, 0xdb, 0x4e, 0xc4,
	0xe9, 0x23, 0xca, 0x7c, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
}

// residue448 is 2^448 mod order.
var residue448 = [4]uint64{
	0x721cf5b5529eec34, 0x7a4cf635c8e9c2ab, 0xeec492d944a725bf, 0x20cd77058,
}

// invFour is 1/4 mod order.
var invFour = Scalar{
	0x3d, 0x11, 0xd6, 0xaa, 0xa4, 0x30, 0xde, 0x48,
	0xd5, 0x63, 0x71, 0xa3, 0x9c, 0x30, 0x5b, 0x08,
	0xa4, 0x8d, 0xb5, 0x6b, 0xd2, 0xb6, 0x13, 0x71,
	0xfa, 0x88, 0x32, 0xdf, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
}

// paramDTwist is -39082 in  The D parameter of the twist curve.
var paramDTwist = Elt{
	0x55, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

// Curve is the Goldilocks curve x^2+y^2=z^2-39081x^2y^2.
type Curve struct{}

// Identity returns the identity point.
func Identity(c Curve) *Point {
	return &Point{
		y: One(),
		z: One(),
	}
}

// IsOnCurve returns true if the point lies on the curve.
func IsOnCurve(c Curve, P *Point) bool {
	x2, y2, t, t2, z2 := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	rhs, lhs := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	EltMul(t, P.ta, P.tb)  // t = ta*tb
	EltSqr(x2, P.x)         // x^2
	EltSqr(y2, P.y)         // y^2
	EltSqr(z2, P.z)         // z^2
	EltSqr(t2, t)            // t^2
	EltAdd(lhs, x2, y2)      // x^2 + y^2

  // paramD is -39081 in
  paramD := Elt{
    0x56, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  }

	EltMul(rhs, t2, paramD) // dt^2
	EltAdd(rhs, rhs, z2)     // z^2 + dt^2
	EltSub(lhs, lhs, rhs)    // x^2 + y^2 - (z^2 + dt^2)
	eq0 := EltIsZero(lhs)

	EltMul(lhs, P.x, P.y) // xy
	EltMul(rhs, t, P.z)    // tz
	Sub(lhs, lhs, rhs)   // xy - tz
	eq1 := EltIsZero(lhs)
	return eq0 && eq1
}

// Generator returns the generator point.
func Generator(c Curve) *Point {
	a := Point{
		x:  genX,
		y:  genY,
		z:  One(),
		ta: genX,
		tb: genY,
	}
	return &a
}

// Order returns the number of points in the prime subgroup.
func Order(c Curve) Scalar { return order }

// Double returns 2P.
func CurveDouble(c Curve, P *Point) *Point {
	R := *P
	Double(R)
	return &R
}

// Add returns P+Q.
func CurveAdd(c Curve, P, Q *Point) *Point {
	R := *P
	Add(R, Q)
	return &R
}

// ScalarMult returns kP. This function runs in constant time.
func CurveScalarMult(e Curve, k *Scalar, P *Point) *Point {
	k4 := &Scalar{}
	divBy4(k4, k)
	return pull(e, twistCurveScalarMult(twistCurve{}, k4, e.push(P)))
}

// ScalarBaseMult returns kG where G is the generator point. This function runs in constant time.
func CurveScalarBaseMult(e Curve, k *Scalar) *Point {
	k4 := &Scalar{}
	divBy4(k4, k)
	return pull(e, twistCurveScalarBaseMult(twistCurve{}, k4))
}

// CombinedMult returns mG+nP, where G is the generator point. This function is non-constant time.
func CurveCombinedMult(e Curve, m, n *Scalar, P *Point) *Point {
	m4 := &Scalar{}
	n4 := &Scalar{}
	divBy4(m4, m)
	divBy4(n4, n)
	return pull(e, twistCurveCombinedMult(twistCurve{}, m4, n4, twistCurvepull(twistCurve{}, P)))
}
func pull(e Curve, P *twistPoint) *Point                { return twistCurvepush(twistCurve{}, P) }
func twistCurvepull(t twistCurve, P *Point) *twistPoint { return push(Curve{}, P) }

// push sends a point on the Goldilocks curve to a point on the twist curve.
func push(c Curve, P *Point) *twistPoint {
	Q := &twistPoint{}
	Px, Py, Pz := P.x, P.y, P.z
	a, b, c, d, e, f, g, h := Q.x, Q.y, Q.z, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Q.ta, Q.x, Q.y, Q.tb
	EltAdd(e, Px, Py)  // x+y
	EltSqr(a, Px)      // A = x^2
	EltSqr(b, Py)      // B = y^2
	EltSqr(c, Pz)      // z^2
	EltAdd(c, c, c)    // C = 2*z^2
	*d = *a         // D = A
	EltSqr(e, e)       // (x+y)^2
	EltSub(e, e, a)    // (x+y)^2-A
	EltSub(e, e, b)    // E = (x+y)^2-A-B
	EltAdd(h, b, d)    // H = B+D
	EltSub(g, b, d)    // G = B-D
	EltSub(f, c, h)    // F = C-H
	EltMul(Q.z, f, g) // Z = F * G
	EltMul(Q.x, e, f) // X = E * F
	EltMul(Q.y, g, h) // Y = G * H, // T = E * H
	return Q
}

// push sends a point on the twist curve to a point on the Goldilocks curve.
func twistCurvepush(e twistCurve, P *twistPoint) *Point {
	Q := &Point{}
	Px, Py, Pz := P.x, P.y, P.z
	a, b, c, d, e, f, g, h := Q.x, Q.y, Q.z, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Q.ta, Q.x, Q.y, Q.tb
	EltAdd(e, Px, Py)  // x+y
	EltSqr(a, Px)      // A = x^2
	EltSqr(b, Py)      // B = y^2
	EltSqr(c, Pz)      // z^2
	EltAdd(c, c, c)    // C = 2*z^2
	EltNeg(d, a)       // D = -A
	EltSqr(e, e)       // (x+y)^2
	EltSub(e, e, a)    // (x+y)^2-A
	EltSub(e, e, b)    // E = (x+y)^2-A-B
	EltAdd(h, b, d)    // H = B+D
	EltSub(g, b, d)    // G = B-D
	EltSub(f, c, h)    // F = C-H
	EltMul(Q.z, f, g) // Z = F * G
	EltMul(Q.x, e, f) // X = E * F
	EltMul(Q.y, g, h) // Y = G * H, // T = E * H
	return Q
}

// Point is a point on the Goldilocks Curve.
type Point struct{ x, y, z, ta, tb Elt }

// FromAffine creates a point from affine coordinates.
func FromAffine(x, y *Elt) (*Point, string) {
	P := &Point{
		x:  *x,
		y:  *y,
		z:  One(),
		ta: *x,
		tb: *y,
	}
	onCurve := IsOnCurve(Curve{}, P)
	if !onCurve {
		return P, "point not on curve"
	}
	return P, nil
}

// isLessThan returns true if 0 <= x < y, and assumes that slices are of the
// same length and are interpreted in little-endian order.
func isLessThan(x, y [56]byte) bool {
	eq := true
	gt := false
	lt := false
	for i := 55; i > 0; i-- {
		eq = !gt && !lt && x[i] == order[i]
		if !eq {
			gt = !lt && x[i] > y[i]
			lt = !gt && x[i] < y[i]
		}
	}
	return x[i] < y[i]
}

// FromBytes returns a point from the input buffer.
func PointFromBytes(in [57]byte) (Point, string) {
	if len(in) < 57 {
		return nil, "wrong input length"
	}
	err := "invalid decoding"
	P := Point{}
	signX := in[56] >> 7
	copy(P.y[:], in[:56])
	p := PMod()
	if !isLessThan(P.y[:], p[:]) {
		return Point{}, err
	}

  // paramD is -39081 in
  paramD := Elt{
    0x56, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  }

	u := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
  v := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	one := One()
	EltSqr(u, P.y)                // u = y^2
	EltMul(v, u, paramD)          // v = dy^2
	EltSub(u, u, one)             // u = y^2-1
	EltSub(v, v, one)             // v = dy^2-1
	isQR := InvSqrt(P.x, u, v) // x = sqrt(u/v)
	if !isQR {
		return P, err
	}
	Modp(P.x) // x = x mod p
	if EltIsZero(P.x) && signX == 1 {
		return P, err
	}
	if signX != (P.x[0] & 1) {
		EltNeg(P.x, P.x)
	}
	P.ta = P.x
	P.tb = P.y
	P.z = One()
	return P, ""
}

// IsIdentity returns true is P is the identity Point.
func IsIdentity(P *Point) bool {
	return EltIsZero(P.x) && !EltIsZero(P.y) && !EltIsZero(P.z) && P.y == P.z
}

// IsEqual returns true if P is equivalent to Q.
func (P *Point) IsEqual(Q *Point) bool {
	l, r := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	Mul(l, P.x, &Q.z)
	Mul(r, &Q.x, P.z)
	Sub(l, l, r)
	b := EltIsZero(l)
	Mul(l, P.y, &Q.z)
	Mul(r, &Q.y, P.z)
	Sub(l, l, r)
	b = b && EltIsZero(l)
	Mul(l, P.ta, P.tb)
	Mul(l, l, &Q.z)
	Mul(r, &Q.ta, &Q.tb)
	Mul(r, r, P.z)
	Sub(l, l, r)
	b = b && EltIsZero(l)
	return b
}

// Neg obtains the inverse of the Point.
func Neg(P *Point) {
	Neg(P.x, P.x)
	Neg(P.ta, P.ta)
}

// ToAffine returns the x,y affine coordinates of P.
func ToAffine(P *Point) (x, y Elt) {
	Inv(P.z, P.z)       // 1/z
	Mul(P.x, P.x, P.z) // x/z
	Mul(P.y, P.y, P.z) // y/z
	Modp(P.x)
	Modp(P.y)
	SetOne(P.z)
	P.ta = P.x
	P.tb = P.y
	return P.x, P.y
}

// ToBytes stores P into a slice of bytes.
func PointToBytes(P *Point, out []byte) string {
	if len(out) < 57 {
		return "invalid decoding"
	}
	x, y := ToAffine(P)
	out[56] = (x[0] & 1) << 7
	return ToBytes(out[:56], &y)
}

// MarshalBinary encodes the receiver into a binary form and returns the result.
func MarshalBinary(P *Point) (data []byte, err error) {
	data = make([]byte, 57)
	err = PointToBytes(P, data[:57])
	return data, err
}

// UnmarshalBinary must be able to decode the form generated by MarshalBinary.
func UnmarshalBinary(P *Point, data []byte) (*Point, error) {
	Q, err := PointFromBytes(data)
	return Q, err
}

// Double sets P = 2Q.
func Double(P *Point) {
	Add(P, P)
}

// Add sets P =P+Q..
func Add(P *Point, Q *Point) {
	// This is formula (5) from "Twisted Edwards Curves Revisited" by
	// Hisil H., Wong K.KH., Carter G., Dawson E. (2008)
	// https://doi.org/10.1007/978-3-540-89255-7_20
	x1, y1, z1, ta1, tb1 := P.x, P.y, P.z, P.ta, P.tb
	x2, y2, z2, ta2, tb2 := &Q.x, &Q.y, &Q.z, &Q.ta, &Q.tb
	x3, y3, z3, E, H := P.x, P.y, P.z, P.ta, P.tb
	A, B, C, D := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	t1, t2, F, G := C, D, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	Mul(t1, ta1, tb1)  // t1 = ta1*tb1
	Mul(t2, ta2, tb2)  // t2 = ta2*tb2
	Mul(A, x1, x2)     // A = x1*x2
	Mul(B, y1, y2)     // B = y1*y2
	Mul(C, t1, t2)     // t1*t2
	Mul(C, C, &paramD) // C = d*t1*t2
	Mul(D, z1, z2)     // D = z1*z2
	Add(F, x1, y1)     // x1+y1
	Add(E, x2, y2)     // x2+y2
	Mul(E, E, F)       // (x1+y1)*(x2+y2)
	Sub(E, E, A)       // (x1+y1)*(x2+y2)-A
	Sub(E, E, B)       // E = (x1+y1)*(x2+y2)-A-B
	Sub(F, D, C)       // F = D-C
	Add(G, D, C)       // G = D+C
	Sub(H, B, A)       // H = B-A
	Mul(z3, F, G)      // Z = F * G
	Mul(x3, E, F)      // X = E * F
	Mul(y3, G, H)      // Y = G * H, T = E * H
}

// Scalar represents a positive integer stored in little-endian order.
type Scalar [56]byte

type scalar64 [7]uint64

func fromScalar(z *scalar64, x *Scalar) {
	z[0] = binary.LittleEndianUint64(x[0*8 : 1*8])
	z[1] = binary.LittleEndianUint64(x[1*8 : 2*8])
	z[2] = binary.LittleEndianUint64(x[2*8 : 3*8])
	z[3] = binary.LittleEndianUint64(x[3*8 : 4*8])
	z[4] = binary.LittleEndianUint64(x[4*8 : 5*8])
	z[5] = binary.LittleEndianUint64(x[5*8 : 6*8])
	z[6] = binary.LittleEndianUint64(x[6*8 : 7*8])
}

func toScalar(z *scalar64, x *Scalar) {
	binary.LittleEndianPutUint64(x[0*8:1*8], z[0])
	binary.LittleEndianPutUint64(x[1*8:2*8], z[1])
	binary.LittleEndianPutUint64(x[2*8:3*8], z[2])
	binary.LittleEndianPutUint64(x[3*8:4*8], z[3])
	binary.LittleEndianPutUint64(x[4*8:5*8], z[4])
	binary.LittleEndianPutUint64(x[5*8:6*8], z[5])
	binary.LittleEndianPutUint64(x[6*8:7*8], z[6])
}

// add calculates z = x + y. Assumes len(z) > max(len(x),len(y)).
func add(z, x, y []uint64) uint64 {
	l, L, zz := len(x), len(y), y
	if l > L {
		l, L, zz = L, l, x
	}
	c := uint64(0)
	for i := 0; i < l; i++ {
		z[i], c = bits.Add64(x[i], y[i], c)
	}
	for i := l; i < L; i++ {
		z[i], c = bits.Add64(zz[i], 0, c)
	}
	return c
}

// sub calculates z = x - y. Assumes len(z) > max(len(x),len(y)).
func sub(z, x, y []uint64) uint64 {
	l, L, zz := len(x), len(y), y
	if l > L {
		l, L, zz = L, l, x
	}
	c := uint64(0)
	for i := 0; i < l; i++ {
		z[i], c = math.Sub64(x[i], y[i], c)
	}
	for i := l; i < L; i++ {
		z[i], c = math.Sub64(zz[i], 0, c)
	}
	return c
}

// mulWord calculates z = x * y. Assumes len(z) >= len(x)+1.
func mulWord(z, x []uint64, y uint64) {
	for i := 0; i < len(z); i++ {
		z[i] = 0
	}
	carry := uint64(0)
	for i := 0; i < len(x); i++ {
		hi, lo := bits.Mul64(x[i], y)
		lo, cc := bits.Add64(lo, z[i], 0)
		hi, _ = bits.Add64(hi, 0, cc)
		z[i], cc = bits.Add64(lo, carry, 0)
		carry, _ = bits.Add64(hi, 0, cc)
	}
	z[len(x)] = carry
}

// Cmov moves x into z if b=1.
func Cmov(z *scalar64, b uint64, x *scalar64) {
	m := uint64(0) - b
	for i := 0; i < len(z); i++ {
		z[i] = (z[i] &^ m) | (x[i] & m)
	}
}

// leftShift shifts to the left the words of z returning the more significant word.
func leftShift(z *scalar64, low uint64) uint64 {
	high := z[6]
	for i := 6; i > 0; i-- {
		z[i] = z[i-1]
	}
	z[0] = low
	return high
}

// reduceOneWord calculates z = z + 2^448*x such that the result fits in a Scalar.
func reduceOneWord(z *scalar64, x uint64) {
	prod := (&scalar64{})[:]
	mulWord(prod, residue448[:], x)
	cc := add(z[:], z[:], prod)
	mulWord(prod, residue448[:], cc)
	add(z[:], z[:], prod)
}

// modOrder reduces z mod order.
func modOrder(z *scalar64) {
	var o64, x scalar64
	o64.fromScalar(&order)
	// Performs: while (z >= order) { z = z-order }
	// At most 8 (eight) iterations reduce 3 bits by subtracting.
	for i := 0; i < 8; i++ {
		c := sub(x[:], z[:], o64[:]) // (c || x) = z-order
		z.Cmov(1-c, &x)              // if c != 0 { z = x }
	}
}

// FromBytes stores z = x mod order, where x is a number stored in little-endian order.
func FromBytes(z *Scalar, x []byte) {
	n := len(x)
	nCeil := (n + 7) >> 3
	for i := 0; i < len(z); i++ {
		z[i] = 0
	}
	if nCeil < 7 {
		copy(z[:], x)
		return
	}
	copy(z[:], x[8*(nCeil-7):])
	var z64 scalar64
	z64.fromScalar(z)
	for i := nCeil - 6; i >= 0; i-- {
		low := binary.LittleEndianUint64(x[8*i:])
		high := z64.leftShift(low)
		z64.reduceOneWord(high)
	}
	z64.modOrder()
	z64.toScalar(z)
}

// divBy4 calculates z = x/4 mod order.
func divBy4(z *Scalar, x *Scalar) {
	z.Mul(x, &invFour)
}

// Red reduces z mod order.
func Red(z *Scalar) {
	var t scalar64
	t.fromScalar(z)
	t.modOrder()
	t.toScalar(z)
}

// Neg calculates z = -z mod order.
func NegScalar(z *Scalar) {
	z.Sub(&order, z)
}

// Add calculates z = x+y mod order.
func AddScalar(z, x, y *Scalar) {
	var z64, x64, y64, t scalar64
	x64.fromScalar(x)
	y64.fromScalar(y)
	c := add(z64[:], x64[:], y64[:])
	add(t[:], z64[:], residue448[:])
	z64.Cmov(c, &t)
	z64.modOrder()
	z64.toScalar(z)
}

// Sub calculates z = x-y mod order.
func SubScalar(z, x, y *Scalar) {
	var z64, x64, y64, t scalar64
	x64.fromScalar(x)
	y64.fromScalar(y)
	c := sub(z64[:], x64[:], y64[:])
	sub(t[:], z64[:], residue448[:])
	z64.Cmov(c, &t)
	z64.modOrder()
	z64.toScalar(z)
}

// Mul calculates z = x*y mod order.
func MulScalar(z, x, y *Scalar) {
	var z64, x64, y64 scalar64
	prod := (&[8]uint64{})[:]
	x64.fromScalar(x)
	y64.fromScalar(y)
	mulWord(prod, x64[:], y64[6])
	copy(z64[:], prod[:7])
	z64.reduceOneWord(prod[7])
	for i := 5; i >= 0; i-- {
		h := z64.leftShift(0)
		z64.reduceOneWord(h)
		mulWord(prod, x64[:], y64[i])
		c := add(z64[:], z64[:], prod[:7])
		z64.reduceOneWord(prod[7] + c)
	}
	z64.modOrder()
	z64.toScalar(z)
}

// IsZero returns true if z=0.
func IsZero(z *Scalar) bool {
	z.Red()
	return *z == Scalar{}
}

// twistCurve is -x^2+y^2=1-39082x^2y^2 and is 4-isogeneous to Goldilocks.
type twistCurve struct{}

// Identity returns the identity point.
func twistCurveIdentity(t twistCurve) *twistPoint {
	return &twistPoint{
		y: One(),
		z: One(),
	}
}

// subYDiv16 update x = (x - y) / 16.
func subYDiv16(x *scalar64, y int64) {
	s := uint64(y >> 63)
	x0, b0 := math.Sub64((*x)[0], uint64(y), 0)
	x1, b1 := math.Sub64((*x)[1], s, b0)
	x2, b2 := math.Sub64((*x)[2], s, b1)
	x3, b3 := math.Sub64((*x)[3], s, b2)
	x4, b4 := math.Sub64((*x)[4], s, b3)
	x5, b5 := math.Sub64((*x)[5], s, b4)
	x6, _ := math.Sub64((*x)[6], s, b5)
	x[0] = (x0 >> 4) | (x1 << 60)
	x[1] = (x1 >> 4) | (x2 << 60)
	x[2] = (x2 >> 4) | (x3 << 60)
	x[3] = (x3 >> 4) | (x4 << 60)
	x[4] = (x4 >> 4) | (x5 << 60)
	x[5] = (x5 >> 4) | (x6 << 60)
	x[6] = (x6 >> 4)
}

func recodeScalar(d *[113]int8, k *Scalar) {
	var k64 scalar64
	k64.fromScalar(k)
	for i := 0; i < 112; i++ {
		d[i] = int8((k64[0] & 0x1f) - 16)
		subYDiv16(&k64, int64(d[i]))
	}
	d[112] = int8(k64[0])
}

// ScalarMult returns kP.
func twistCurveScalarMult(e twistCurve, k *Scalar, P *twistPoint) *twistPoint {
	var TabP [8]preTwistPointProy
	var S preTwistPointProy
	var d [113]int8

	var isZero int
	if IsZero(k) {
		isZero = 1
	}
	subtle.ConstantTimeCopy(isZero, k[:], order[:])

	minusK := *k
	isEven := 1 - int(k[0]&0x1)
	minusK.Neg()
	subtle.ConstantTimeCopy(isEven, k[:], minusK[:])
	recodeScalar(&d, k)

	P.oddMultiples(TabP[:])
	Q := e.twistCurveIdentity()
	for i := 112; i >= 0; i-- {
		Q.Double()
		Q.Double()
		Q.Double()
		Q.Double()
		mask := d[i] >> 7
		absDi := (d[i] + mask) ^ mask
		inx := int32((absDi - 1) >> 1)
		sig := int((d[i] >> 7) & 0x1)
		for j := 0; j < len(TabP); j++ {
			S.cmov(&TabP[j], uint(subtle.ConstantTimeEq(inx, int32(j))))
		}
		S.cneg(sig)
		Q.mixAdd(&S)
	}
	Q.cneg(uint(isEven))
	return Q
}

const (
	omegaFix = 7
	omegaVar = 5
)

// CombinedMult returns mG+nP.
func twistCurveCombinedMult(e twistCurve, m, n *Scalar, P *twistPoint) *twistPoint {
	nafFix := OmegaNAF(BytesLe2BigInt(m[:]), omegaFix)
	nafVar := OmegaNAF(BytesLe2BigInt(n[:]), omegaVar)

	if len(nafFix) > len(nafVar) {
		l := len(nafFix) - len(nafVar)
		ne := make([]int32, l)
		for i := 0; i < l; i++ {
			nafVar = append(nafVar, ne[i])
		}
	} else if len(nafFix) < len(nafVar) {
		l := len(nafVar) - len(nafFix)
		ne := make([]int32, l)
		for i := 0; i < l; i++ {
			nafFix = append(nafFix, ne[i])
		}
	}

	var TabQ [1 << (omegaVar - 2)]preTwistPointProy
	P.oddMultiples(TabQ[:])
	Q := e.twistCurveIdentity()
	for i := len(nafFix) - 1; i >= 0; i-- {
		Q.Double()
		// Generator point
		if nafFix[i] != 0 {
			idxM := absolute(nafFix[i]) >> 1
			R := tabVerif[idxM]
			if nafFix[i] < 0 {
				R.neg()
			}
			Q.mixAddZ1(&R)
		}
		// Variable input point
		if nafVar[i] != 0 {
			idxN := absolute(nafVar[i]) >> 1
			S := TabQ[idxN]
			if nafVar[i] < 0 {
				S.neg()
			}
			Q.mixAdd(&S)
		}
	}
	return Q
}

// absolute returns always a positive value.
func absolute(x int32) int32 {
	mask := x >> 31
	return (x + mask) ^ mask
}

type twistPoint struct{ x, y, z, ta, tb Elt }

type preTwistPointAffine struct{ addYX, subYX, dt2 Elt }

type preTwistPointProy struct {
	p  preTwistPointAffine
	z2 Elt
}

// cneg conditionally negates the point if b=1.
func (P *twistPoint) cneg(b uint) {
	t := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	Neg(t, P.x)
	Cmov(P.x, t, b)
	Neg(t, P.ta)
	Cmov(P.ta, t, b)
}

// Double updates P with 2P.
func (P *twistPoint) Double() {
	// This is formula (7) from "Twisted Edwards Curves Revisited" by
	// Hisil H., Wong K.KH., Carter G., Dawson E. (2008)
	// https://doi.org/10.1007/978-3-540-89255-7_20
	Px, Py, Pz, Pta, Ptb := P.x, P.y, P.z, P.ta, P.tb
	a, b, c, e, f, g, h := Px, Py, Pz, Pta, Px, Py, Ptb
	Add(e, Px, Py) // x+y
	Sqr(a, Px)     // A = x^2
	Sqr(b, Py)     // B = y^2
	Sqr(c, Pz)     // z^2
	Add(c, c, c)   // C = 2*z^2
	Add(h, a, b)   // H = A+B
	Sqr(e, e)      // (x+y)^2
	Sub(e, e, h)   // E = (x+y)^2-A-B
	Sub(g, b, a)   // G = B-A
	Sub(f, c, g)   // F = C-G
	Mul(Pz, f, g)  // Z = F * G
	Mul(Px, e, f)  // X = E * F
	Mul(Py, g, h)  // Y = G * H, T = E * H
}

// mixAdd calculates P= P+Q, where Q is a precomputed point with Z_Q = 1.
func (P *twistPoint) mixAddZ1(Q *preTwistPointAffine) {
	Add(P.z, P.z, P.z) // D = 2*z1 (z2=1)
	P.coreAddition(Q)
}

// coreAddition calculates P=P+Q for curves with A=-1.
func (P *twistPoint) coreAddition(Q *preTwistPointAffine) {
	// This is the formula following (5) from "Twisted Edwards Curves Revisited" by
	// Hisil H., Wong K.KH., Carter G., Dawson E. (2008)
	// https://doi.org/10.1007/978-3-540-89255-7_20
	Px, Py, Pz, Pta, Ptb := P.x, P.y, P.z, P.ta, P.tb
	addYX2, subYX2, dt2 := &Q.addYX, &Q.subYX, &Q.dt2
	a, b, c, d, e, f, g, h := Px, Py, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Pz, Pta, Px, Py, Ptb
	Mul(c, Pta, Ptb)  // t1 = ta*tb
	Sub(h, Py, Px)    // y1-x1
	Add(b, Py, Px)    // y1+x1
	Mul(a, h, subYX2) // A = (y1-x1)*(y2-x2)
	Mul(b, b, addYX2) // B = (y1+x1)*(y2+x2)
	Mul(c, c, dt2)    // C = 2*D*t1*t2
	Sub(e, b, a)      // E = B-A
	Add(h, b, a)      // H = B+A
	Sub(f, d, c)      // F = D-C
	Add(g, d, c)      // G = D+C
	Mul(Pz, f, g)     // Z = F * G
	Mul(Px, e, f)     // X = E * F
	Mul(Py, g, h)     // Y = G * H, T = E * H
}

func (P *preTwistPointAffine) neg() {
	P.addYX, P.subYX = P.subYX, P.addYX
	Neg(P.dt2, P.dt2)
}

func (P *preTwistPointAffine) cneg(b int) {
	t := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	Cswap(P.addYX, P.subYX, uint(b))
	Neg(t, P.dt2)
	Cmov(P.dt2, t, uint(b))
}

func (P *preTwistPointAffine) cmov(Q *preTwistPointAffine, b uint) {
	Cmov(P.addYX, &Q.addYX, b)
	Cmov(P.subYX, &Q.subYX, b)
	Cmov(P.dt2, &Q.dt2, b)
}

// mixAdd calculates P= P+Q, where Q is a precomputed point with Z_Q != 1.
func mixAdd(P *twistPoint, Q *preTwistPointProy) {
	Mul(P.z, P.z, &Q.z2) // D = 2*z1*z2
	P.coreAddition(&Q.preTwistPointAffine)
}

// oddMultiples calculates T[i] = (2*i-1)P for 0 < i < len(T).
func (P *twistPoint) oddMultiples(T []preTwistPointProy) {
	n := len(T)
	if n > 0 {
		FromTwistPoint(T[0], P)
		_2P := *P
		Double(_2P)
		R := &preTwistPointProy{}
		FromTwistPoint(R, &_2P)
		for i := 1; i < n; i++ {
			mixAdd(P, R)
			FromTwistPoint(T[i], P)
		}
	}
}

// cmov conditionally moves Q into P if b=1.
func cmov(P *preTwistPointProy, Q *preTwistPointProy, b uint) {
	cmov(P.preTwistPointAffine, &Q.preTwistPointAffine, b)
	Cmov(P.z2, &Q.z2, b)
}

// FromTwistPoint precomputes some coordinates of Q for missed addition.
func FromTwistPoint(P *preTwistPointProy, Q *twistPoint) {
	Add(P.addYX, &Q.y, &Q.x)         // addYX = X + Y
	Sub(P.subYX, &Q.y, &Q.x)         // subYX = Y - X
	Mul(P.dt2, &Q.ta, &Q.tb)         // T = ta*tb
	Mul(P.dt2, P.dt2, &paramDTwist) // D*T
	Add(P.dt2, P.dt2, P.dt2)       // dt2 = 2*D*T
	Add(P.z2, &Q.z, &Q.z)            // z2 = 2*Z
}

var tabFixMult = [fxV][fx2w1]preTwistPointAffine{
	{
		{
			addYX: Elt{0x65, 0x4a, 0xdd, 0xdf, 0xb4, 0x79, 0x60, 0xc8, 0xa1, 0x70, 0xb4, 0x3a, 0x1e, 0x0c, 0x9b, 0x19, 0xe5, 0x48, 0x3f, 0xd7, 0x44, 0x18, 0x18, 0x14, 0x14, 0x27, 0x45, 0xd0, 0x2b, 0x24, 0xd5, 0x93, 0xc3, 0x74, 0x4c, 0x50, 0x70, 0x43, 0x26, 0x05, 0x08, 0x24, 0xca, 0x78, 0x30, 0xc1, 0x06, 0x8d, 0xd4, 0x86, 0x42, 0xf0, 0x14, 0xde, 0x08, 0x05},
			subYX: Elt{0x64, 0x4a, 0xdd, 0xdf, 0xb4, 0x79, 0x60, 0xc8, 0xa1, 0x70, 0xb4, 0x3a, 0x1e, 0x0c, 0x9b, 0x19, 0xe5, 0x48, 0x3f, 0xd7, 0x44, 0x18, 0x18, 0x14, 0x14, 0x27, 0x45, 0xd0, 0x2d, 0x24, 0xd5, 0x93, 0xc3, 0x74, 0x4c, 0x50, 0x70, 0x43, 0x26, 0x05, 0x08, 0x24, 0xca, 0x78, 0x30, 0xc1, 0x06, 0x8d, 0xd4, 0x86, 0x42, 0xf0, 0x14, 0xde, 0x08, 0x05},
			dt2:   Elt{0x1a, 0x33, 0xea, 0x64, 0x45, 0x1c, 0xdf, 0x17, 0x1d, 0x16, 0x34, 0x28, 0xd6, 0x61, 0x19, 0x67, 0x79, 0xb4, 0x13, 0xcf, 0x3e, 0x7c, 0x0e, 0x72, 0xda, 0xf1, 0x5f, 0xda, 0xe6, 0xcf, 0x42, 0xd3, 0xb6, 0x17, 0xc2, 0x68, 0x13, 0x2d, 0xd9, 0x60, 0x3e, 0xae, 0xf0, 0x5b, 0x96, 0xf0, 0xcd, 0xaf, 0xea, 0xb7, 0x0d, 0x59, 0x16, 0xa7, 0xff, 0x55},
		},
		{
			addYX: Elt{0xca, 0xd8, 0x7d, 0x86, 0x1a, 0xef, 0xad, 0x11, 0xe3, 0x27, 0x41, 0x7e, 0x7f, 0x3e, 0xa9, 0xd2, 0xb5, 0x4e, 0x50, 0xe0, 0x77, 0x91, 0xc2, 0x13, 0x52, 0x73, 0x41, 0x09, 0xa6, 0x57, 0x9a, 0xc8, 0xa8, 0x90, 0x9d, 0x26, 0x14, 0xbb, 0xa1, 0x2a, 0xf7, 0x45, 0x43, 0x4e, 0xea, 0x35, 0x62, 0xe1, 0x08, 0x85, 0x46, 0xb8, 0x24, 0x05, 0x2d, 0xab},
			subYX: Elt{0x9b, 0xe6, 0xd3, 0xe5, 0xfe, 0x50, 0x36, 0x3c, 0x3c, 0x6d, 0x74, 0x1d, 0x74, 0xc0, 0xde, 0x5b, 0x45, 0x27, 0xe5, 0x12, 0xee, 0x63, 0x35, 0x6b, 0x13, 0xe2, 0x41, 0x6b, 0x3a, 0x05, 0x2b, 0xb1, 0x89, 0x26, 0xb6, 0xc6, 0xd1, 0x84, 0xff, 0x0e, 0x9b, 0xa3, 0xfb, 0x21, 0x36, 0x6b, 0x01, 0xf7, 0x9f, 0x7c, 0xeb, 0xf5, 0x18, 0x7a, 0x2a, 0x70},
			dt2:   Elt{0x09, 0xad, 0x99, 0x1a, 0x38, 0xd3, 0xdf, 0x22, 0x37, 0x32, 0x61, 0x8b, 0xf3, 0x19, 0x48, 0x08, 0xe8, 0x49, 0xb6, 0x4a, 0xa7, 0xed, 0xa4, 0xa2, 0xee, 0x86, 0xd7, 0x31, 0x5e, 0xce, 0x95, 0x76, 0x86, 0x42, 0x1c, 0x9d, 0x07, 0x14, 0x8c, 0x34, 0x18, 0x9c, 0x6d, 0x3a, 0xdf, 0xa9, 0xe8, 0x36, 0x7e, 0xe4, 0x95, 0xbe, 0xb5, 0x09, 0xf8, 0x9c},
		},
		{
			addYX: Elt{0x51, 0xdb, 0x49, 0xa8, 0x9f, 0xe3, 0xd7, 0xec, 0x0d, 0x0f, 0x49, 0xe8, 0xb6, 0xc5, 0x0f, 0x5a, 0x1c, 0xce, 0x54, 0x0d, 0xb1, 0x8d, 0x5b, 0xbf, 0xf4, 0xaa, 0x34, 0x77, 0xc4, 0x5d, 0x59, 0xb6, 0xc5, 0x0e, 0x5a, 0xd8, 0x5b, 0x30, 0xc2, 0x1d, 0xec, 0x85, 0x1c, 0x42, 0xbe, 0x24, 0x2e, 0x50, 0x55, 0x44, 0xb2, 0x3a, 0x01, 0xaa, 0x98, 0xfb},
			subYX: Elt{0xe7, 0x29, 0xb7, 0xd0, 0xaa, 0x4f, 0x32, 0x53, 0x56, 0xde, 0xbc, 0xd1, 0x92, 0x5d, 0x19, 0xbe, 0xa3, 0xe3, 0x75, 0x48, 0xe0, 0x7a, 0x1b, 0x54, 0x7a, 0xb7, 0x41, 0x77, 0x84, 0x38, 0xdd, 0x14, 0x9f, 0xca, 0x3f, 0xa3, 0xc8, 0xa7, 0x04, 0x70, 0xf1, 0x4d, 0x3d, 0xb3, 0x84, 0x79, 0xcb, 0xdb, 0xe4, 0xc5, 0x42, 0x9b, 0x57, 0x19, 0xf1, 0x2d},
			dt2:   Elt{0x20, 0xb4, 0x94, 0x9e, 0xdf, 0x31, 0x44, 0x0b, 0xc9, 0x7b, 0x75, 0x40, 0x9d, 0xd1, 0x96, 0x39, 0x70, 0x71, 0x15, 0xc8, 0x93, 0xd5, 0xc5, 0xe5, 0xba, 0xfe, 0xee, 0x08, 0x6a, 0x98, 0x0a, 0x1b, 0xb2, 0xaa, 0x3a, 0xf4, 0xa4, 0x79, 0xf9, 0x8e, 0x4d, 0x65, 0x10, 0x9b, 0x3a, 0x6e, 0x7c, 0x87, 0x94, 0x92, 0x11, 0x65, 0xbf, 0x1a, 0x09, 0xde},
		},
		{
			addYX: Elt{0xf3, 0x84, 0x76, 0x77, 0xa5, 0x6b, 0x27, 0x3b, 0x83, 0x3d, 0xdf, 0xa0, 0xeb, 0x32, 0x6d, 0x58, 0x81, 0x57, 0x64, 0xc2, 0x21, 0x7c, 0x9b, 0xea, 0xe6, 0xb0, 0x93, 0xf9, 0xe7, 0xc3, 0xed, 0x5a, 0x8e, 0xe2, 0xb4, 0x72, 0x76, 0x66, 0x0f, 0x22, 0x29, 0x94, 0x3e, 0x63, 0x48, 0x5e, 0x80, 0xcb, 0xac, 0xfa, 0x95, 0xb6, 0x4b, 0xc4, 0x95, 0x33},
			subYX: Elt{0x0c, 0x55, 0xd1, 0x5e, 0x5f, 0xbf, 0xbf, 0xe2, 0x4c, 0xfc, 0x37, 0x4a, 0xc4, 0xb1, 0xf4, 0x83, 0x61, 0x93, 0x60, 0x8e, 0x9f, 0x31, 0xf0, 0xa0, 0x41, 0xff, 0x1d, 0xe2, 0x7f, 0xca, 0x40, 0xd6, 0x88, 0xe8, 0x91, 0x61, 0xe2, 0x11, 0x18, 0x83, 0xf3, 0x25, 0x2f, 0x3f, 0x49, 0x40, 0xd4, 0x83, 0xe2, 0xd7, 0x74, 0x6a, 0x16, 0x86, 0x4e, 0xab},
			dt2:   Elt{0xdd, 0x58, 0x65, 0xd8, 0x9f, 0xdd, 0x70, 0x7f, 0x0f, 0xec, 0xbd, 0x5c, 0x5c, 0x9b, 0x7e, 0x1b, 0x9f, 0x79, 0x36, 0x1f, 0xfd, 0x79, 0x10, 0x1c, 0x52, 0xf3, 0x22, 0xa4, 0x1f, 0x71, 0x6e, 0x63, 0x14, 0xf4, 0xa7, 0x3e, 0xbe, 0xad, 0x43, 0x30, 0x38, 0x8c, 0x29, 0xc6, 0xcf, 0x50, 0x75, 0x21, 0xe5, 0x78, 0xfd, 0xb0, 0x9a, 0xc4, 0x6d, 0xd4},
		},
	},
	{
		{
			addYX: Elt{0x7a, 0xa1, 0x38, 0xa6, 0xfd, 0x0e, 0x96, 0xd5, 0x26, 0x76, 0x86, 0x70, 0x80, 0x30, 0xa6, 0x67, 0xeb, 0xf4, 0x39, 0xdb, 0x22, 0xf5, 0x9f, 0x98, 0xe4, 0xb5, 0x3a, 0x0c, 0x59, 0xbf, 0x85, 0xc6, 0xf0, 0x0b, 0x1c, 0x41, 0x38, 0x09, 0x01, 0xdb, 0xd6, 0x3c, 0xb7, 0xf1, 0x08, 0x6b, 0x4b, 0x9e, 0x63, 0x53, 0x83, 0xd3, 0xab, 0xa3, 0x72, 0x0d},
			subYX: Elt{0x84, 0x68, 0x25, 0xe8, 0xe9, 0x8f, 0x91, 0xbf, 0xf7, 0xa4, 0x30, 0xae, 0xea, 0x9f, 0xdd, 0x56, 0x64, 0x09, 0xc9, 0x54, 0x68, 0x4e, 0x33, 0xc5, 0x6f, 0x7b, 0x2d, 0x52, 0x2e, 0x42, 0xbe, 0xbe, 0xf5, 0x64, 0xbf, 0x77, 0x54, 0xdf, 0xb0, 0x10, 0xd2, 0x16, 0x5d, 0xce, 0xaf, 0x9f, 0xfb, 0xa3, 0x63, 0x50, 0xcb, 0xc0, 0xd0, 0x88, 0x44, 0xa3},
			dt2:   Elt{0xc3, 0x8b, 0xa5, 0xf1, 0x44, 0xe4, 0x41, 0xcd, 0x75, 0xe3, 0x17, 0x69, 0x5b, 0xb9, 0xbb, 0xee, 0x82, 0xbb, 0xce, 0x57, 0xdf, 0x2a, 0x9c, 0x12, 0xab, 0x66, 0x08, 0x68, 0x05, 0x1b, 0x87, 0xee, 0x5d, 0x1e, 0x18, 0x14, 0x22, 0x4b, 0x99, 0x61, 0x75, 0x28, 0xe7, 0x65, 0x1c, 0x36, 0xb6, 0x18, 0x09, 0xa8, 0xdf, 0xef, 0x30, 0x35, 0xbc, 0x58},
		},
		{
			addYX: Elt{0xc5, 0xd3, 0x0e, 0x6f, 0xaf, 0x06, 0x69, 0xc4, 0x07, 0x9e, 0x58, 0x6e, 0x3f, 0x49, 0xd9, 0x0a, 0x3c, 0x2c, 0x37, 0xcd, 0x27, 0x4d, 0x87, 0x91, 0x7a, 0xb0, 0x28, 0xad, 0x2f, 0x68, 0x92, 0x05, 0x97, 0xf1, 0x30, 0x5f, 0x4c, 0x10, 0x20, 0x30, 0xd3, 0x08, 0x3f, 0xc1, 0xc6, 0xb7, 0xb5, 0xd1, 0x71, 0x7b, 0xa8, 0x0a, 0xd8, 0xf5, 0x17, 0xcf},
			subYX: Elt{0x64, 0xd4, 0x8f, 0x91, 0x40, 0xab, 0x6e, 0x1a, 0x62, 0x83, 0xdc, 0xd7, 0x30, 0x1a, 0x4a, 0x2a, 0x4c, 0x54, 0x86, 0x19, 0x81, 0x5d, 0x04, 0x52, 0xa3, 0xca, 0x82, 0x38, 0xdc, 0x1e, 0xf0, 0x7a, 0x78, 0x76, 0x49, 0x4f, 0x71, 0xc4, 0x74, 0x2f, 0xf0, 0x5b, 0x2e, 0x5e, 0xac, 0xef, 0x17, 0xe4, 0x8e, 0x6e, 0xed, 0x43, 0x23, 0x61, 0x99, 0x49},
			dt2:   Elt{0x64, 0x90, 0x72, 0x76, 0xf8, 0x2c, 0x7d, 0x57, 0xf9, 0x30, 0x5e, 0x7a, 0x10, 0x74, 0x19, 0x39, 0xd9, 0xaf, 0x0a, 0xf1, 0x43, 0xed, 0x88, 0x9c, 0x8b, 0xdc, 0x9b, 0x1c, 0x90, 0xe7, 0xf7, 0xa3, 0xa5, 0x0d, 0xc6, 0xbc, 0x30, 0xfb, 0x91, 0x1a, 0x51, 0xba, 0x2d, 0xbe, 0x89, 0xdf, 0x1d, 0xdc, 0x53, 0xa8, 0x82, 0x8a, 0xd3, 0x8d, 0x16, 0x68},
		},
		{
			addYX: Elt{0xef, 0x5c, 0xe3, 0x74, 0xbf, 0x13, 0x4a, 0xbf, 0x66, 0x73, 0x64, 0xb7, 0xd4, 0xce, 0x98, 0x82, 0x05, 0xfa, 0x98, 0x0c, 0x0a, 0xae, 0xe5, 0x6b, 0x9f, 0xac, 0xbb, 0x6e, 0x1f, 0xcf, 0xff, 0xa6, 0x71, 0x9a, 0xa8, 0x7a, 0x9e, 0x64, 0x1f, 0x20, 0x4a, 0x61, 0xa2, 0xd6, 0x50, 0xe3, 0xba, 0x81, 0x0c, 0x50, 0x59, 0x69, 0x59, 0x15, 0x55, 0xdb},
			subYX: Elt{0xe8, 0x77, 0x4d, 0xe8, 0x66, 0x3d, 0xc1, 0x00, 0x3c, 0xf2, 0x25, 0x00, 0xdc, 0xb2, 0xe5, 0x9b, 0x12, 0x89, 0xf3, 0xd6, 0xea, 0x85, 0x60, 0xfe, 0x67, 0x91, 0xfd, 0x04, 0x7c, 0xe0, 0xf1, 0x86, 0x06, 0x11, 0x66, 0xee, 0xd4, 0xd5, 0xbe, 0x3b, 0x0f, 0xe3, 0x59, 0xb3, 0x4f, 0x00, 0xb6, 0xce, 0x80, 0xc1, 0x61, 0xf7, 0xaf, 0x04, 0x6a, 0x3c},
			dt2:   Elt{0x00, 0xd7, 0x32, 0x93, 0x67, 0x70, 0x6f, 0xd7, 0x69, 0xab, 0xb1, 0xd3, 0xdc, 0xd6, 0xa8, 0xdd, 0x35, 0x25, 0xca, 0xd3, 0x8a, 0x6d, 0xce, 0xfb, 0xfd, 0x2b, 0x83, 0xf0, 0xd4, 0xac, 0x66, 0xfb, 0x72, 0x87, 0x7e, 0x55, 0xb7, 0x91, 0x58, 0x10, 0xc3, 0x11, 0x7e, 0x15, 0xfe, 0x7c, 0x55, 0x90, 0xa3, 0x9e, 0xed, 0x9a, 0x7f, 0xa7, 0xb7, 0xeb},
		},
		{
			addYX: Elt{0x25, 0x0f, 0xc2, 0x09, 0x9c, 0x10, 0xc8, 0x7c, 0x93, 0xa7, 0xbe, 0xe9, 0x26, 0x25, 0x7c, 0x21, 0xfe, 0xe7, 0x5f, 0x3c, 0x02, 0x83, 0xa7, 0x9e, 0xdf, 0xc0, 0x94, 0x2b, 0x7d, 0x1a, 0xd0, 0x1d, 0xcc, 0x2e, 0x7d, 0xd4, 0x85, 0xe7, 0xc1, 0x15, 0x66, 0xd6, 0xd6, 0x32, 0xb8, 0xf7, 0x63, 0xaa, 0x3b, 0xa5, 0xea, 0x49, 0xad, 0x88, 0x9b, 0x66},
			subYX: Elt{0x09, 0x97, 0x79, 0x36, 0x41, 0x56, 0x9b, 0xdf, 0x15, 0xd8, 0x43, 0x28, 0x17, 0x5b, 0x96, 0xc9, 0xcf, 0x39, 0x1f, 0x13, 0xf7, 0x4d, 0x1d, 0x1f, 0xda, 0x51, 0x56, 0xe7, 0x0a, 0x5a, 0x65, 0xb6, 0x2a, 0x87, 0x49, 0x86, 0xc2, 0x2b, 0xcd, 0xfe, 0x07, 0xf6, 0x4c, 0xe2, 0x1d, 0x9b, 0xd8, 0x82, 0x09, 0x5b, 0x11, 0x10, 0x62, 0x56, 0x89, 0xbd},
			dt2:   Elt{0xd9, 0x15, 0x73, 0xf2, 0x96, 0x35, 0x53, 0xb0, 0xe7, 0xa8, 0x0b, 0x93, 0x35, 0x0b, 0x3a, 0x00, 0xf5, 0x18, 0xb1, 0xc3, 0x12, 0x3f, 0x91, 0x17, 0xc1, 0x4c, 0x15, 0x5a, 0x86, 0x92, 0x11, 0xbd, 0x44, 0x40, 0x5a, 0x7b, 0x15, 0x89, 0xba, 0xc1, 0xc1, 0xbc, 0x43, 0x45, 0xe6, 0x52, 0x02, 0x73, 0x0a, 0xd0, 0x2a, 0x19, 0xda, 0x47, 0xa8, 0xff},
		},
	},
}

// tabVerif contains the odd multiples of P. The entry T[i] = (2i+1)P, where
// P = phi(G) and G is the generator of the Goldilocks curve, and phi is a
// 4-degree isogeny.
var tabVerif = [1 << (omegaFix - 2)]preTwistPointAffine{
	{ /* 1P*/
		addYX: Elt{0x65, 0x4a, 0xdd, 0xdf, 0xb4, 0x79, 0x60, 0xc8, 0xa1, 0x70, 0xb4, 0x3a, 0x1e, 0x0c, 0x9b, 0x19, 0xe5, 0x48, 0x3f, 0xd7, 0x44, 0x18, 0x18, 0x14, 0x14, 0x27, 0x45, 0xd0, 0x2b, 0x24, 0xd5, 0x93, 0xc3, 0x74, 0x4c, 0x50, 0x70, 0x43, 0x26, 0x05, 0x08, 0x24, 0xca, 0x78, 0x30, 0xc1, 0x06, 0x8d, 0xd4, 0x86, 0x42, 0xf0, 0x14, 0xde, 0x08, 0x05},
		subYX: Elt{0x64, 0x4a, 0xdd, 0xdf, 0xb4, 0x79, 0x60, 0xc8, 0xa1, 0x70, 0xb4, 0x3a, 0x1e, 0x0c, 0x9b, 0x19, 0xe5, 0x48, 0x3f, 0xd7, 0x44, 0x18, 0x18, 0x14, 0x14, 0x27, 0x45, 0xd0, 0x2d, 0x24, 0xd5, 0x93, 0xc3, 0x74, 0x4c, 0x50, 0x70, 0x43, 0x26, 0x05, 0x08, 0x24, 0xca, 0x78, 0x30, 0xc1, 0x06, 0x8d, 0xd4, 0x86, 0x42, 0xf0, 0x14, 0xde, 0x08, 0x05},
		dt2:   Elt{0x1a, 0x33, 0xea, 0x64, 0x45, 0x1c, 0xdf, 0x17, 0x1d, 0x16, 0x34, 0x28, 0xd6, 0x61, 0x19, 0x67, 0x79, 0xb4, 0x13, 0xcf, 0x3e, 0x7c, 0x0e, 0x72, 0xda, 0xf1, 0x5f, 0xda, 0xe6, 0xcf, 0x42, 0xd3, 0xb6, 0x17, 0xc2, 0x68, 0x13, 0x2d, 0xd9, 0x60, 0x3e, 0xae, 0xf0, 0x5b, 0x96, 0xf0, 0xcd, 0xaf, 0xea, 0xb7, 0x0d, 0x59, 0x16, 0xa7, 0xff, 0x55},
	},
	{ /* 3P*/
		addYX: Elt{0xd1, 0xe9, 0xa8, 0x33, 0x20, 0x76, 0x18, 0x08, 0x45, 0x2a, 0xc9, 0x67, 0x2a, 0xc3, 0x15, 0x24, 0xf9, 0x74, 0x21, 0x30, 0x99, 0x59, 0x8b, 0xb2, 0xf0, 0xa4, 0x07, 0xe2, 0x6a, 0x36, 0x8d, 0xd9, 0xd2, 0x4a, 0x7f, 0x73, 0x50, 0x39, 0x3d, 0xaa, 0xa7, 0x51, 0x73, 0x0d, 0x2b, 0x8b, 0x96, 0x47, 0xac, 0x3c, 0x5d, 0xaa, 0x39, 0x9c, 0xcf, 0xd5},
		subYX: Elt{0x6b, 0x11, 0x5d, 0x1a, 0xf9, 0x41, 0x9d, 0xc5, 0x30, 0x3e, 0xad, 0x25, 0x2c, 0x04, 0x45, 0xea, 0xcc, 0x67, 0x07, 0x85, 0xe9, 0xda, 0x0e, 0xb5, 0x40, 0xb7, 0x32, 0xb4, 0x49, 0xdd, 0xff, 0xaa, 0xfc, 0xbb, 0x19, 0xca, 0x8b, 0x79, 0x2b, 0x8f, 0x8d, 0x00, 0x33, 0xc2, 0xad, 0xe9, 0xd3, 0x12, 0xa8, 0xaa, 0x87, 0x62, 0xad, 0x2d, 0xff, 0xa4},
		dt2:   Elt{0xb0, 0xaf, 0x3b, 0xea, 0xf0, 0x42, 0x0b, 0x5e, 0x88, 0xd3, 0x98, 0x08, 0x87, 0x59, 0x72, 0x0a, 0xc2, 0xdf, 0xcb, 0x7f, 0x59, 0xb5, 0x4c, 0x63, 0x68, 0xe8, 0x41, 0x38, 0x67, 0x4f, 0xe9, 0xc6, 0xb2, 0x6b, 0x08, 0xa7, 0xf7, 0x0e, 0xcd, 0xea, 0xca, 0x3d, 0xaf, 0x8e, 0xda, 0x4b, 0x2e, 0xd2, 0x88, 0x64, 0x8d, 0xc5, 0x5f, 0x76, 0x0f, 0x3d},
	},
	{ /* 5P*/
		addYX: Elt{0xe5, 0x65, 0xc9, 0xe2, 0x75, 0xf0, 0x7d, 0x1a, 0xba, 0xa4, 0x40, 0x4b, 0x93, 0x12, 0xa2, 0x80, 0x95, 0x0d, 0x03, 0x93, 0xe8, 0xa5, 0x4d, 0xe2, 0x3d, 0x81, 0xf5, 0xce, 0xd4, 0x2d, 0x25, 0x59, 0x16, 0x5c, 0xe7, 0xda, 0xc7, 0x45, 0xd2, 0x7e, 0x2c, 0x38, 0xd4, 0x37, 0x64, 0xb2, 0xc2, 0x28, 0xc5, 0x72, 0x16, 0x32, 0x45, 0x36, 0x6f, 0x9f},
		subYX: Elt{0x09, 0xf4, 0x7e, 0xbd, 0x89, 0xdb, 0x19, 0x58, 0xe1, 0x08, 0x00, 0x8a, 0xf4, 0x5f, 0x2a, 0x32, 0x40, 0xf0, 0x2c, 0x3f, 0x5d, 0xe4, 0xfc, 0x89, 0x11, 0x24, 0xb4, 0x2f, 0x97, 0xad, 0xac, 0x8f, 0x19, 0xab, 0xfa, 0x12, 0xe5, 0xf9, 0x50, 0x4e, 0x50, 0x6f, 0x32, 0x30, 0x88, 0xa6, 0xe5, 0x48, 0x28, 0xa2, 0x1b, 0x9f, 0xcd, 0xe2, 0x43, 0x38},
		dt2:   Elt{0xa9, 0xcc, 0x53, 0x39, 0x86, 0x02, 0x60, 0x75, 0x34, 0x99, 0x57, 0xbd, 0xfc, 0x5a, 0x8e, 0xce, 0x5e, 0x98, 0x22, 0xd0, 0xa5, 0x24, 0xff, 0x90, 0x28, 0x9f, 0x58, 0xf3, 0x39, 0xe9, 0xba, 0x36, 0x23, 0xfb, 0x7f, 0x41, 0xcc, 0x2b, 0x5a, 0x25, 0x3f, 0x4c, 0x2a, 0xf1, 0x52, 0x6f, 0x2f, 0x07, 0xe3, 0x88, 0x81, 0x77, 0xdd, 0x7c, 0x88, 0x82},
	},
	{ /* 7P*/
		addYX: Elt{0xf7, 0xee, 0x88, 0xfd, 0x3a, 0xbf, 0x7e, 0x28, 0x39, 0x23, 0x79, 0xe6, 0x5c, 0x56, 0xcb, 0xb5, 0x48, 0x6a, 0x80, 0x6d, 0x37, 0x60, 0x6c, 0x10, 0x35, 0x49, 0x4b, 0x46, 0x60, 0xd4, 0x79, 0xd4, 0x53, 0xd3, 0x67, 0x88, 0xd0, 0x41, 0xd5, 0x43, 0x85, 0xc8, 0x71, 0xe3, 0x1c, 0xb6, 0xda, 0x22, 0x64, 0x8f, 0x80, 0xac, 0xad, 0x7d, 0xd5, 0x82},
		subYX: Elt{0x92, 0x40, 0xc1, 0x83, 0x21, 0x9b, 0xd5, 0x7d, 0x3f, 0x29, 0xb6, 0x26, 0xef, 0x12, 0xb9, 0x27, 0x39, 0x42, 0x37, 0x97, 0x09, 0x9a, 0x08, 0xe1, 0x68, 0xb6, 0x7a, 0x3f, 0x9f, 0x45, 0xf8, 0x37, 0x19, 0x83, 0x97, 0xe6, 0x73, 0x30, 0x32, 0x35, 0xcf, 0xae, 0x5c, 0x12, 0x68, 0xdf, 0x6e, 0x2b, 0xde, 0x83, 0xa0, 0x44, 0x74, 0x2e, 0x4a, 0xe9},
		dt2:   Elt{0xcb, 0x22, 0x0a, 0xda, 0x6b, 0xc1, 0x8a, 0x29, 0xa1, 0xac, 0x8b, 0x5b, 0x8b, 0x32, 0x20, 0xf2, 0x21, 0xae, 0x0c, 0x43, 0xc4, 0xd7, 0x19, 0x37, 0x3d, 0x79, 0x25, 0x98, 0x6c, 0x9c, 0x22, 0x31, 0x2a, 0x55, 0x9f, 0xda, 0x5e, 0xa8, 0x13, 0xdb, 0x8e, 0x2e, 0x16, 0x39, 0xf4, 0x91, 0x6f, 0xec, 0x71, 0x71, 0xc9, 0x10, 0xf2, 0xa4, 0x8f, 0x11},
	},
	{ /* 9P*/
		addYX: Elt{0x85, 0xdd, 0x37, 0x62, 0x74, 0x8e, 0x33, 0x5b, 0x25, 0x12, 0x1b, 0xe7, 0xdf, 0x47, 0xe5, 0x12, 0xfd, 0x3a, 0x3a, 0xf5, 0x5d, 0x4c, 0xa2, 0x29, 0x3c, 0x5c, 0x2f, 0xee, 0x18, 0x19, 0x0a, 0x2b, 0xef, 0x67, 0x50, 0x7a, 0x0d, 0x29, 0xae, 0x55, 0x82, 0xcd, 0xd6, 0x41, 0x90, 0xb4, 0x13, 0x31, 0x5d, 0x11, 0xb8, 0xaa, 0x12, 0x86, 0x08, 0xac},
		subYX: Elt{0xcc, 0x37, 0x8d, 0x83, 0x5f, 0xfd, 0xde, 0xd5, 0xf7, 0xf1, 0xae, 0x0a, 0xa7, 0x0b, 0xeb, 0x6d, 0x19, 0x8a, 0xb6, 0x1a, 0x59, 0xd8, 0xff, 0x3c, 0xbc, 0xbc, 0xef, 0x9c, 0xda, 0x7b, 0x75, 0x12, 0xaf, 0x80, 0x8f, 0x2c, 0x3c, 0xaa, 0x0b, 0x17, 0x86, 0x36, 0x78, 0x18, 0xc8, 0x8a, 0xf6, 0xb8, 0x2c, 0x2f, 0x57, 0x2c, 0x62, 0x57, 0xf6, 0x90},
		dt2:   Elt{0x83, 0xbc, 0xa2, 0x07, 0xa5, 0x38, 0x96, 0xea, 0xfe, 0x11, 0x46, 0x1d, 0x3b, 0xcd, 0x42, 0xc5, 0xee, 0x67, 0x04, 0x72, 0x08, 0xd8, 0xd9, 0x96, 0x07, 0xf7, 0xac, 0xc3, 0x64, 0xf1, 0x98, 0x2c, 0x55, 0xd7, 0x7d, 0xc8, 0x6c, 0xbd, 0x2c, 0xff, 0x15, 0xd6, 0x6e, 0xb8, 0x17, 0x8e, 0xa8, 0x27, 0x66, 0xb1, 0x73, 0x79, 0x96, 0xff, 0x29, 0x10},
	},
	{ /* 11P*/
		addYX: Elt{0x76, 0xcb, 0x9b, 0x0c, 0x5b, 0xfe, 0xe1, 0x2a, 0xdd, 0x6f, 0x6c, 0xdd, 0x6f, 0xb4, 0xc0, 0xc2, 0x1b, 0x4b, 0x38, 0xe8, 0x66, 0x8c, 0x1e, 0x31, 0x63, 0xb9, 0x94, 0xcd, 0xc3, 0x8c, 0x44, 0x25, 0x7b, 0xd5, 0x39, 0x80, 0xfc, 0x01, 0xaa, 0xf7, 0x2a, 0x61, 0x8a, 0x25, 0xd2, 0x5f, 0xc5, 0x66, 0x38, 0xa4, 0x17, 0xcf, 0x3e, 0x11, 0x0f, 0xa3},
		subYX: Elt{0xe0, 0xb6, 0xd1, 0x9c, 0x71, 0x49, 0x2e, 0x7b, 0xde, 0x00, 0xda, 0x6b, 0xf1, 0xec, 0xe6, 0x7a, 0x15, 0x38, 0x71, 0xe9, 0x7b, 0xdb, 0xf8, 0x98, 0xc0, 0x91, 0x2e, 0x53, 0xee, 0x92, 0x87, 0x25, 0xc9, 0xb0, 0xbb, 0x33, 0x15, 0x46, 0x7f, 0xfd, 0x4f, 0x8b, 0x77, 0x05, 0x96, 0xb6, 0xe2, 0x08, 0xdb, 0x0d, 0x09, 0xee, 0x5b, 0xd1, 0x2a, 0x63},
		dt2:   Elt{0x8f, 0x7b, 0x57, 0x8c, 0xbf, 0x06, 0x0d, 0x43, 0x21, 0x92, 0x94, 0x2d, 0x6a, 0x38, 0x07, 0x0f, 0xa0, 0xf1, 0xe3, 0xd8, 0x2a, 0xbf, 0x46, 0xc6, 0x9e, 0x1f, 0x8f, 0x2b, 0x46, 0x84, 0x0b, 0x74, 0xed, 0xff, 0xf8, 0xa5, 0x94, 0xae, 0xf1, 0x67, 0xb1, 0x9b, 0xdd, 0x4a, 0xd0, 0xdb, 0xc2, 0xb5, 0x58, 0x49, 0x0c, 0xa9, 0x1d, 0x7d, 0xa9, 0xd3},
	},
	{ /* 13P*/
		addYX: Elt{0x73, 0x84, 0x2e, 0x31, 0x1f, 0xdc, 0xed, 0x9f, 0x74, 0xfa, 0xe0, 0x35, 0xb1, 0x85, 0x6a, 0x8d, 0x86, 0xd0, 0xff, 0xd6, 0x08, 0x43, 0x73, 0x1a, 0xd5, 0xf8, 0x43, 0xd4, 0xb3, 0xe5, 0x3f, 0xa8, 0x84, 0x17, 0x59, 0x65, 0x4e, 0xe6, 0xee, 0x54, 0x9c, 0xda, 0x5e, 0x7e, 0x98, 0x29, 0x6d, 0x73, 0x34, 0x1f, 0x99, 0x80, 0x54, 0x54, 0x81, 0x0b},
		subYX: Elt{0xb1, 0xe5, 0xbb, 0x80, 0x22, 0x9c, 0x81, 0x6d, 0xaf, 0x27, 0x65, 0x6f, 0x7e, 0x9c, 0xb6, 0x8d, 0x35, 0x5c, 0x2e, 0x20, 0x48, 0x7a, 0x28, 0xf0, 0x97, 0xfe, 0xb7, 0x71, 0xce, 0xd6, 0xad, 0x3a, 0x81, 0xf6, 0x74, 0x5e, 0xf3, 0xfd, 0x1b, 0xd4, 0x1e, 0x7c, 0xc2, 0xb7, 0xc8, 0xa6, 0xc9, 0x89, 0x03, 0x47, 0xec, 0x24, 0xd6, 0x0e, 0xec, 0x9c},
		dt2:   Elt{0x91, 0x0a, 0x43, 0x34, 0x20, 0xc2, 0x64, 0xf7, 0x4e, 0x48, 0xc8, 0xd2, 0x95, 0x83, 0xd1, 0xa4, 0xfb, 0x4e, 0x41, 0x3b, 0x0d, 0xd5, 0x07, 0xd9, 0xf1, 0x13, 0x16, 0x78, 0x54, 0x57, 0xd0, 0xf1, 0x4f, 0x20, 0xac, 0xcf, 0x9c, 0x3b, 0x33, 0x0b, 0x99, 0x54, 0xc3, 0x7f, 0x3e, 0x57, 0x26, 0x86, 0xd5, 0xa5, 0x2b, 0x8d, 0xe3, 0x19, 0x36, 0xf7},
	},
	{ /* 15P*/
		addYX: Elt{0x23, 0x69, 0x47, 0x14, 0xf9, 0x9a, 0x50, 0xff, 0x64, 0xd1, 0x50, 0x35, 0xc3, 0x11, 0xd3, 0x19, 0xcf, 0x87, 0xda, 0x30, 0x0b, 0x50, 0xda, 0xc0, 0xe0, 0x25, 0x00, 0xe5, 0x68, 0x93, 0x04, 0xc2, 0xaf, 0xbd, 0x2f, 0x36, 0x5f, 0x47, 0x96, 0x10, 0xa8, 0xbd, 0xe4, 0x88, 0xac, 0x80, 0x52, 0x61, 0x73, 0xe9, 0x63, 0xdd, 0x99, 0xad, 0x20, 0x5b},
		subYX: Elt{0x1b, 0x5e, 0xa2, 0x2a, 0x25, 0x0f, 0x86, 0xc0, 0xb1, 0x2e, 0x0c, 0x13, 0x40, 0x8d, 0xf0, 0xe6, 0x00, 0x55, 0x08, 0xc5, 0x7d, 0xf4, 0xc9, 0x31, 0x25, 0x3a, 0x99, 0x69, 0xdd, 0x67, 0x63, 0x9a, 0xd6, 0x89, 0x2e, 0xa1, 0x19, 0xca, 0x2c, 0xd9, 0x59, 0x5f, 0x5d, 0xc3, 0x6e, 0x62, 0x36, 0x12, 0x59, 0x15, 0xe1, 0xdc, 0xa4, 0xad, 0xc9, 0xd0},
		dt2:   Elt{0xbc, 0xea, 0xfc, 0xaf, 0x66, 0x23, 0xb7, 0x39, 0x6b, 0x2a, 0x96, 0xa8, 0x54, 0x43, 0xe9, 0xaa, 0x32, 0x40, 0x63, 0x92, 0x5e, 0xdf, 0x35, 0xc2, 0x9f, 0x24, 0x0c, 0xed, 0xfc, 0xde, 0x73, 0x8f, 0xa7, 0xd5, 0xa3, 0x2b, 0x18, 0x1f, 0xb0, 0xf8, 0xeb, 0x55, 0xd9, 0xc3, 0xfd, 0x28, 0x7c, 0x4f, 0xce, 0x0d, 0xf7, 0xae, 0xc2, 0x83, 0xc3, 0x78},
	},
	{ /* 17P*/
		addYX: Elt{0x71, 0xe6, 0x60, 0x93, 0x37, 0xdb, 0x01, 0xa5, 0x4c, 0xba, 0xe8, 0x8e, 0xd5, 0xf9, 0xd3, 0x98, 0xe5, 0xeb, 0xab, 0x3a, 0x15, 0x8b, 0x35, 0x60, 0xbe, 0xe5, 0x9c, 0x2d, 0x10, 0x9b, 0x2e, 0xcf, 0x65, 0x64, 0xea, 0x8f, 0x72, 0xce, 0xf5, 0x18, 0xe5, 0xe2, 0xf0, 0x0e, 0xae, 0x04, 0xec, 0xa0, 0x20, 0x65, 0x63, 0x07, 0xb1, 0x9f, 0x03, 0x97},
		subYX: Elt{0x9e, 0x41, 0x64, 0x30, 0x95, 0x7f, 0x3a, 0x89, 0x7b, 0x0a, 0x79, 0x59, 0x23, 0x9a, 0x3b, 0xfe, 0xa4, 0x13, 0x08, 0xb2, 0x2e, 0x04, 0x50, 0x10, 0x30, 0xcd, 0x2e, 0xa4, 0x91, 0x71, 0x50, 0x36, 0x4a, 0x02, 0xf4, 0x8d, 0xa3, 0x36, 0x1b, 0xf4, 0x52, 0xba, 0x15, 0x04, 0x8b, 0x80, 0x25, 0xd9, 0xae, 0x67, 0x20, 0xd9, 0x88, 0x8f, 0x97, 0xa6},
		dt2:   Elt{0xb5, 0xe7, 0x46, 0xbd, 0x55, 0x23, 0xa0, 0x68, 0xc0, 0x12, 0xd9, 0xf1, 0x0a, 0x75, 0xe2, 0xda, 0xf4, 0x6b, 0xca, 0x14, 0xe4, 0x9f, 0x0f, 0xb5, 0x3c, 0xa6, 0xa5, 0xa2, 0x63, 0x94, 0xd1, 0x1c, 0x39, 0x58, 0x57, 0x02, 0x27, 0x98, 0xb6, 0x47, 0xc6, 0x61, 0x4b, 0x5c, 0xab, 0x6f, 0x2d, 0xab, 0xe3, 0xc1, 0x69, 0xf9, 0x12, 0xb0, 0xc8, 0xd5},
	},
	{ /* 19P*/
		addYX: Elt{0x19, 0x7d, 0xd5, 0xac, 0x79, 0xa2, 0x82, 0x9b, 0x28, 0x31, 0x22, 0xc0, 0x73, 0x02, 0x76, 0x17, 0x10, 0x70, 0x79, 0x57, 0xc9, 0x84, 0x62, 0x8e, 0x04, 0x04, 0x61, 0x67, 0x08, 0x48, 0xb4, 0x4b, 0xde, 0x53, 0x8c, 0xff, 0x36, 0x1b, 0x62, 0x86, 0x5d, 0xe1, 0x9b, 0xb1, 0xe5, 0xe8, 0x44, 0x64, 0xa1, 0x68, 0x3f, 0xa8, 0x45, 0x52, 0x91, 0xed},
		subYX: Elt{0x42, 0x1a, 0x36, 0x1f, 0x90, 0x15, 0x24, 0x8d, 0x24, 0x80, 0xe6, 0xfe, 0x1e, 0xf0, 0xad, 0xaf, 0x6a, 0x93, 0xf0, 0xa6, 0x0d, 0x5d, 0xea, 0xf6, 0x62, 0x96, 0x7a, 0x05, 0x76, 0x85, 0x74, 0x32, 0xc7, 0xc8, 0x64, 0x53, 0x62, 0xe7, 0x54, 0x84, 0xe0, 0x40, 0x66, 0x19, 0x70, 0x40, 0x95, 0x35, 0x68, 0x64, 0x43, 0xcd, 0xba, 0x29, 0x32, 0xa8},
		dt2:   Elt{0x3e, 0xf6, 0xd6, 0xe4, 0x99, 0xeb, 0x20, 0x66, 0x08, 0x2e, 0x26, 0x64, 0xd7, 0x76, 0xf3, 0xb4, 0xc5, 0xa4, 0x35, 0x92, 0xd2, 0x99, 0x70, 0x5a, 0x1a, 0xe9, 0xe9, 0x3d, 0x3b, 0xe1, 0xcd, 0x0e, 0xee, 0x24, 0x13, 0x03, 0x22, 0xd6, 0xd6, 0x72, 0x08, 0x2b, 0xde, 0xfd, 0x93, 0xed, 0x0c, 0x7f, 0x5e, 0x31, 0x22, 0x4d, 0x80, 0x78, 0xc0, 0x48},
	},
	{ /* 21P*/
		addYX: Elt{0x8f, 0x72, 0xd2, 0x9e, 0xc4, 0xcd, 0x2c, 0xbf, 0xa8, 0xd3, 0x24, 0x62, 0x28, 0xee, 0x39, 0x0a, 0x19, 0x3a, 0x58, 0xff, 0x21, 0x2e, 0x69, 0x6c, 0x6e, 0x18, 0xd0, 0xcd, 0x61, 0xc1, 0x18, 0x02, 0x5a, 0xe9, 0xe3, 0xef, 0x1f, 0x8e, 0x10, 0xe8, 0x90, 0x2b, 0x48, 0xcd, 0xee, 0x38, 0xbd, 0x3a, 0xca, 0xbc, 0x2d, 0xe2, 0x3a, 0x03, 0x71, 0x02},
		subYX: Elt{0xf8, 0xa4, 0x32, 0x26, 0x66, 0xaf, 0x3b, 0x53, 0xe7, 0xb0, 0x91, 0x92, 0xf5, 0x3c, 0x74, 0xce, 0xf2, 0xdd, 0x68, 0xa9, 0xf4, 0xcd, 0x5f, 0x60, 0xab, 0x71, 0xdf, 0xcd, 0x5c, 0x5d, 0x51, 0x72, 0x3a, 0x96, 0xea, 0xd6, 0xde, 0x54, 0x8e, 0x55, 0x4c, 0x08, 0x4c, 0x60, 0xdd, 0x34, 0xa9, 0x6f, 0xf3, 0x04, 0x02, 0xa8, 0xa6, 0x4e, 0x4d, 0x62},
		dt2:   Elt{0x76, 0x4a, 0xae, 0x38, 0x62, 0x69, 0x72, 0xdc, 0xe8, 0x43, 0xbe, 0x1d, 0x61, 0xde, 0x31, 0xc3, 0x42, 0x8f, 0x33, 0x9d, 0xca, 0xc7, 0x9c, 0xec, 0x6a, 0xe2, 0xaa, 0x01, 0x49, 0x78, 0x8d, 0x72, 0x4f, 0x38, 0xea, 0x52, 0xc2, 0xd3, 0xc9, 0x39, 0x71, 0xba, 0xb9, 0x09, 0x9b, 0xa3, 0x7f, 0x45, 0x43, 0x65, 0x36, 0x29, 0xca, 0xe7, 0x5c, 0x5f},
	},
	{ /* 23P*/
		addYX: Elt{0x89, 0x42, 0x35, 0x48, 0x6d, 0x74, 0xe5, 0x1f, 0xc3, 0xdd, 0x28, 0x5b, 0x84, 0x41, 0x33, 0x9f, 0x42, 0xf3, 0x1d, 0x5d, 0x15, 0x6d, 0x76, 0x33, 0x36, 0xaf, 0xe9, 0xdd, 0xfa, 0x63, 0x4f, 0x7a, 0x9c, 0xeb, 0x1c, 0x4f, 0x34, 0x65, 0x07, 0x54, 0xbb, 0x4c, 0x8b, 0x62, 0x9d, 0xd0, 0x06, 0x99, 0xb3, 0xe9, 0xda, 0x85, 0x19, 0xb0, 0x3d, 0x3c},
		subYX: Elt{0xbb, 0x99, 0xf6, 0xbf, 0xaf, 0x2c, 0x22, 0x0d, 0x7a, 0xaa, 0x98, 0x6f, 0x01, 0x82, 0x99, 0xcf, 0x88, 0xbd, 0x0e, 0x3a, 0x89, 0xe0, 0x9c, 0x8c, 0x17, 0x20, 0xc4, 0xe0, 0xcf, 0x43, 0x7a, 0xef, 0x0d, 0x9f, 0x87, 0xd4, 0xfb, 0xf2, 0x96, 0xb8, 0x03, 0xe8, 0xcb, 0x5c, 0xec, 0x65, 0x5f, 0x49, 0xa4, 0x7c, 0x85, 0xb4, 0xf6, 0xc7, 0xdb, 0xa3},
		dt2:   Elt{0x11, 0xf3, 0x32, 0xa3, 0xa7, 0xb2, 0x7d, 0x51, 0x82, 0x44, 0xeb, 0xa2, 0x7d, 0x72, 0xcb, 0xc6, 0xf6, 0xc7, 0xb2, 0x38, 0x0e, 0x0f, 0x4f, 0x29, 0x00, 0xe4, 0x5b, 0x94, 0x46, 0x86, 0x66, 0xa1, 0x83, 0xb3, 0xeb, 0x15, 0xb6, 0x31, 0x50, 0x28, 0xeb, 0xed, 0x0d, 0x32, 0x39, 0xe9, 0x23, 0x81, 0x99, 0x3e, 0xff, 0x17, 0x4c, 0x11, 0x43, 0xd1},
	},
	{ /* 25P*/
		addYX: Elt{0xce, 0xe7, 0xf8, 0x94, 0x8f, 0x96, 0xf8, 0x96, 0xe6, 0x72, 0x20, 0x44, 0x2c, 0xa7, 0xfc, 0xba, 0xc8, 0xe1, 0xbb, 0xc9, 0x16, 0x85, 0xcd, 0x0b, 0xe5, 0xb5, 0x5a, 0x7f, 0x51, 0x43, 0x63, 0x8b, 0x23, 0x8e, 0x1d, 0x31, 0xff, 0x46, 0x02, 0x66, 0xcc, 0x9e, 0x4d, 0xa2, 0xca, 0xe2, 0xc7, 0xfd, 0x22, 0xb1, 0xdb, 0xdf, 0x6f, 0xe6, 0xa5, 0x82},
		subYX: Elt{0xd0, 0xf5, 0x65, 0x40, 0xec, 0x8e, 0x65, 0x42, 0x78, 0xc1, 0x65, 0xe4, 0x10, 0xc8, 0x0b, 0x1b, 0xdd, 0x96, 0x68, 0xce, 0xee, 0x45, 0x55, 0xd8, 0x6e, 0xd3, 0xe6, 0x77, 0x19, 0xae, 0xc2, 0x8d, 0x8d, 0x3e, 0x14, 0x3f, 0x6d, 0x00, 0x2f, 0x9b, 0xd1, 0x26, 0x60, 0x28, 0x0f, 0x3a, 0x47, 0xb3, 0xe6, 0x68, 0x28, 0x24, 0x25, 0xca, 0xc8, 0x06},
		dt2:   Elt{0x54, 0xbb, 0x60, 0x92, 0xdb, 0x8f, 0x0f, 0x38, 0xe0, 0xe6, 0xe4, 0xc9, 0xcc, 0x14, 0x62, 0x01, 0xc4, 0x2b, 0x0f, 0xcf, 0xed, 0x7d, 0x8e, 0xa4, 0xd9, 0x73, 0x0b, 0xba, 0x0c, 0xaf, 0x0c, 0xf9, 0xe2, 0xeb, 0x29, 0x2a, 0x53, 0xdf, 0x2c, 0x5a, 0xfa, 0x8f, 0xc1, 0x01, 0xd7, 0xb1, 0x45, 0x73, 0x92, 0x32, 0x83, 0x85, 0x12, 0x74, 0x89, 0x44},
	},
	{ /* 27P*/
		addYX: Elt{0x0b, 0x73, 0x3c, 0xc2, 0xb1, 0x2e, 0xe1, 0xa7, 0xf5, 0xc9, 0x7a, 0xfb, 0x3d, 0x2d, 0xac, 0x59, 0xdb, 0xfa, 0x36, 0x11, 0xd1, 0x13, 0x04, 0x51, 0x1d, 0xab, 0x9b, 0x6b, 0x93, 0xfe, 0xda, 0xb0, 0x8e, 0xb4, 0x79, 0x11, 0x21, 0x0f, 0x65, 0xb9, 0xbb, 0x79, 0x96, 0x2a, 0xfd, 0x30, 0xe0, 0xb4, 0x2d, 0x9a, 0x55, 0x25, 0x5d, 0xd4, 0xad, 0x2a},
		subYX: Elt{0x9e, 0xc5, 0x04, 0xfe, 0xec, 0x3c, 0x64, 0x1c, 0xed, 0x95, 0xed, 0xae, 0xaf, 0x5c, 0x6e, 0x08, 0x9e, 0x02, 0x29, 0x59, 0x7e, 0x5f, 0xc4, 0x9a, 0xd5, 0x32, 0x72, 0x86, 0xe1, 0x4e, 0x3c, 0xce, 0x99, 0x69, 0x3b, 0xc4, 0xdd, 0x4d, 0xb7, 0xbb, 0xda, 0x3b, 0x1a, 0x99, 0xaa, 0x62, 0x15, 0xc1, 0xf0, 0xb6, 0x6c, 0xec, 0x56, 0xc1, 0xff, 0x0c},
		dt2:   Elt{0x2f, 0xf1, 0x3f, 0x7a, 0x2d, 0x56, 0x19, 0x7f, 0xea, 0xbe, 0x59, 0x2e, 0x13, 0x67, 0x81, 0xfb, 0xdb, 0xc8, 0xa3, 0x1d, 0xd5, 0xe9, 0x13, 0x8b, 0x29, 0xdf, 0xcf, 0x9f, 0xe7, 0xd9, 0x0b, 0x70, 0xd3, 0x15, 0x57, 0x4a, 0xe9, 0x50, 0x12, 0x1b, 0x81, 0x4b, 0x98, 0x98, 0xa8, 0x31, 0x1d, 0x27, 0x47, 0x38, 0xed, 0x57, 0x99, 0x26, 0xb2, 0xee},
	},
	{ /* 29P*/
		addYX: Elt{0x1c, 0xb2, 0xb2, 0x67, 0x3b, 0x8b, 0x3d, 0x5a, 0x30, 0x7e, 0x38, 0x7e, 0x3c, 0x3d, 0x28, 0x56, 0x59, 0xd8, 0x87, 0x53, 0x8b, 0xe6, 0x6c, 0x5d, 0xe5, 0x0a, 0x33, 0x10, 0xce, 0xa2, 0x17, 0x0d, 0xe8, 0x76, 0xee, 0x68, 0xa8, 0x72, 0x54, 0xbd, 0xa6, 0x24, 0x94, 0x6e, 0x77, 0xc7, 0x53, 0xb7, 0x89, 0x1c, 0x7a, 0xe9, 0x78, 0x9a, 0x74, 0x5f},
		subYX: Elt{0x76, 0x96, 0x1c, 0xcf, 0x08, 0x55, 0xd8, 0x1e, 0x0d, 0xa3, 0x59, 0x95, 0x32, 0xf4, 0xc2, 0x8e, 0x84, 0x5e, 0x4b, 0x04, 0xda, 0x71, 0xc9, 0x78, 0x52, 0xde, 0x14, 0xb4, 0x31, 0xf4, 0xd4, 0xb8, 0x58, 0xc5, 0x20, 0xe8, 0xdd, 0x15, 0xb5, 0xee, 0xea, 0x61, 0xe0, 0xf5, 0xd6, 0xae, 0x55, 0x59, 0x05, 0x3e, 0xaf, 0x74, 0xac, 0x1f, 0x17, 0x82},
		dt2:   Elt{0x59, 0x24, 0xcd, 0xfc, 0x11, 0x7e, 0x85, 0x18, 0x3d, 0x69, 0xf7, 0x71, 0x31, 0x66, 0x98, 0x42, 0x95, 0x00, 0x8c, 0xb2, 0xae, 0x39, 0x7e, 0x85, 0xd6, 0xb0, 0x02, 0xec, 0xce, 0xfc, 0x25, 0xb2, 0xe3, 0x99, 0x8e, 0x5b, 0x61, 0x96, 0x2e, 0x6d, 0x96, 0x57, 0x71, 0xa5, 0x93, 0x41, 0x0e, 0x6f, 0xfd, 0x0a, 0xbf, 0xa9, 0xf7, 0x56, 0xa9, 0x3e},
	},
	{ /* 31P*/
		addYX: Elt{0xa2, 0x2e, 0x0c, 0x17, 0x4d, 0xcc, 0x85, 0x2c, 0x18, 0xa0, 0xd2, 0x08, 0xba, 0x11, 0xfa, 0x47, 0x71, 0x86, 0xaf, 0x36, 0x6a, 0xd7, 0xfe, 0xb9, 0xb0, 0x2f, 0x89, 0x98, 0x49, 0x69, 0xf8, 0x6a, 0xad, 0x27, 0x5e, 0x0a, 0x22, 0x60, 0x5e, 0x5d, 0xca, 0x06, 0x51, 0x27, 0x99, 0x29, 0x85, 0x68, 0x98, 0xe1, 0xc4, 0x21, 0x50, 0xa0, 0xe9, 0xc1},
		subYX: Elt{0x4d, 0x70, 0xee, 0x91, 0x92, 0x3f, 0xb7, 0xd3, 0x1d, 0xdb, 0x8d, 0x6e, 0x16, 0xf5, 0x65, 0x7d, 0x5f, 0xb5, 0x6c, 0x59, 0x26, 0x70, 0x4b, 0xf2, 0xfc, 0xe7, 0xdf, 0x86, 0xfe, 0xa5, 0xa7, 0xa6, 0x5d, 0xfb, 0x06, 0xe9, 0xf9, 0xcc, 0xc0, 0x37, 0xcc, 0xd8, 0x09, 0x04, 0xd2, 0xa5, 0x1d, 0xd7, 0xb7, 0xce, 0x92, 0xac, 0x3c, 0xad, 0xfb, 0xae},
		dt2:   Elt{0x17, 0xa3, 0x9a, 0xc7, 0x86, 0x2a, 0x51, 0xf7, 0x96, 0x79, 0x49, 0x22, 0x2e, 0x5a, 0x01, 0x5c, 0xb5, 0x95, 0xd4, 0xe8, 0xcb, 0x00, 0xca, 0x2d, 0x55, 0xb6, 0x34, 0x36, 0x0b, 0x65, 0x46, 0xf0, 0x49, 0xfc, 0x87, 0x86, 0xe5, 0xc3, 0x15, 0xdb, 0x32, 0xcd, 0xf2, 0xd3, 0x82, 0x4c, 0xe6, 0x61, 0x8a, 0xaf, 0xd4, 0x9e, 0x0f, 0x5a, 0xf2, 0x81},
	},
	{ /* 33P*/
		addYX: Elt{0x88, 0x10, 0xc0, 0xcb, 0xf5, 0x77, 0xae, 0xa5, 0xbe, 0xf6, 0xcd, 0x2e, 0x8b, 0x7e, 0xbd, 0x79, 0x62, 0x4a, 0xeb, 0x69, 0xc3, 0x28, 0xaa, 0x72, 0x87, 0xa9, 0x25, 0x87, 0x46, 0xea, 0x0e, 0x62, 0xa3, 0x6a, 0x1a, 0xe2, 0xba, 0xdc, 0x81, 0x10, 0x33, 0x01, 0xf6, 0x16, 0x89, 0x80, 0xc6, 0xcd, 0xdb, 0xdc, 0xba, 0x0e, 0x09, 0x4a, 0x35, 0x4a},
		subYX: Elt{0x86, 0xb2, 0x2b, 0xd0, 0xb8, 0x4a, 0x6d, 0x66, 0x7b, 0x32, 0xdf, 0x3b, 0x1a, 0x19, 0x1f, 0x63, 0xee, 0x1f, 0x3d, 0x1c, 0x5c, 0x14, 0x60, 0x5b, 0x72, 0x49, 0x07, 0xb1, 0x0d, 0x72, 0xc6, 0x35, 0xf0, 0xbc, 0x5e, 0xda, 0x80, 0x6b, 0x64, 0x5b, 0xe5, 0x34, 0x54, 0x39, 0xdd, 0xe6, 0x3c, 0xcb, 0xe5, 0x29, 0x32, 0x06, 0xc6, 0xb1, 0x96, 0x34},
		dt2:   Elt{0x85, 0x86, 0xf5, 0x84, 0x86, 0xe6, 0x77, 0x8a, 0x71, 0x85, 0x0c, 0x4f, 0x81, 0x5b, 0x29, 0x06, 0xb5, 0x2e, 0x26, 0x71, 0x07, 0x78, 0x07, 0xae, 0xbc, 0x95, 0x46, 0xc3, 0x65, 0xac, 0xe3, 0x76, 0x51, 0x7d, 0xd4, 0x85, 0x31, 0xe3, 0x43, 0xf3, 0x1b, 0x7c, 0xf7, 0x6b, 0x2c, 0xf8, 0x1c, 0xbb, 0x8d, 0xca, 0xab, 0x4b, 0xba, 0x7f, 0xa4, 0xe2},
	},
	{ /* 35P*/
		addYX: Elt{0x1a, 0xee, 0xe7, 0xa4, 0x8a, 0x9d, 0x53, 0x80, 0xc6, 0xb8, 0x4e, 0xdc, 0x89, 0xe0, 0xc4, 0x2b, 0x60, 0x52, 0x6f, 0xec, 0x81, 0xd2, 0x55, 0x6b, 0x1b, 0x6f, 0x17, 0x67, 0x8e, 0x42, 0x26, 0x4c, 0x65, 0x23, 0x29, 0xc6, 0x7b, 0xcd, 0x9f, 0xad, 0x4b, 0x42, 0xd3, 0x0c, 0x75, 0xc3, 0x8a, 0xf5, 0xbe, 0x9e, 0x55, 0xf7, 0x47, 0x5d, 0xbd, 0x3a},
		subYX: Elt{0x0d, 0xa8, 0x3b, 0xf9, 0xc7, 0x7e, 0xc6, 0x86, 0x94, 0xc0, 0x01, 0xff, 0x27, 0xce, 0x43, 0xac, 0xe5, 0xe1, 0xd2, 0x8d, 0xc1, 0x22, 0x31, 0xbe, 0xe1, 0xaf, 0xf9, 0x4a, 0x78, 0xa1, 0x0c, 0xaa, 0xd4, 0x80, 0xe4, 0x09, 0x8d, 0xfb, 0x1d, 0x52, 0xc8, 0x60, 0x2d, 0xf2, 0xa2, 0x89, 0x02, 0x56, 0x3d, 0x56, 0x27, 0x85, 0xc7, 0xf0, 0x2b, 0x9a},
		dt2:   Elt{0x62, 0x7c, 0xc7, 0x6b, 0x2c, 0x9d, 0x0a, 0x7c, 0xe5, 0x50, 0x3c, 0xe6, 0x87, 0x1c, 0x82, 0x30, 0x67, 0x3c, 0x39, 0xb6, 0xa0, 0x31, 0xfb, 0x03, 0x7b, 0xa1, 0x58, 0xdf, 0x12, 0x76, 0x5d, 0x5d, 0x0a, 0x8f, 0x9b, 0x37, 0x32, 0xc3, 0x60, 0x33, 0xea, 0x9f, 0x0a, 0x99, 0xfa, 0x20, 0xd0, 0x33, 0x21, 0xc3, 0x94, 0xd4, 0x86, 0x49, 0x7c, 0x4e},
	},
	{ /* 37P*/
		addYX: Elt{0xc7, 0x0c, 0x71, 0xfe, 0x55, 0xd1, 0x95, 0x8f, 0x43, 0xbb, 0x6b, 0x74, 0x30, 0xbd, 0xe8, 0x6f, 0x1c, 0x1b, 0x06, 0x62, 0xf5, 0xfc, 0x65, 0xa0, 0xeb, 0x81, 0x12, 0xc9, 0x64, 0x66, 0x61, 0xde, 0xf3, 0x6d, 0xd4, 0xae, 0x8e, 0xb1, 0x72, 0xe0, 0xcd, 0x37, 0x01, 0x28, 0x52, 0xd7, 0x39, 0x46, 0x0c, 0x55, 0xcf, 0x47, 0x70, 0xef, 0xa1, 0x17},
		subYX: Elt{0x8d, 0x58, 0xde, 0x83, 0x88, 0x16, 0x0e, 0x12, 0x42, 0x03, 0x50, 0x60, 0x4b, 0xdf, 0xbf, 0x95, 0xcc, 0x7d, 0x18, 0x17, 0x7e, 0x31, 0x5d, 0x8a, 0x66, 0xc1, 0xcf, 0x14, 0xea, 0xf4, 0xf4, 0xe5, 0x63, 0x2d, 0x32, 0x86, 0x9b, 0xed, 0x1f, 0x4f, 0x03, 0xaf, 0x33, 0x92, 0xcb, 0xaf, 0x9c, 0x05, 0x0d, 0x47, 0x1b, 0x42, 0xba, 0x13, 0x22, 0x98},
		dt2:   Elt{0xb5, 0x48, 0xeb, 0x7d, 0x3d, 0x10, 0x9f, 0x59, 0xde, 0xf8, 0x1c, 0x4f, 0x7d, 0x9d, 0x40, 0x4d, 0x9e, 0x13, 0x24, 0xb5, 0x21, 0x09, 0xb7, 0xee, 0x98, 0x5c, 0x56, 0xbc, 0x5e, 0x2b, 0x78, 0x38, 0x06, 0xac, 0xe3, 0xe0, 0xfa, 0x2e, 0xde, 0x4f, 0xd2, 0xb3, 0xfb, 0x2d, 0x71, 0x84, 0xd1, 0x9d, 0x12, 0x5b, 0x35, 0xc8, 0x03, 0x68, 0x67, 0xc7},
	},
	{ /* 39P*/
		addYX: Elt{0xb6, 0x65, 0xfb, 0xa7, 0x06, 0x35, 0xbb, 0xe0, 0x31, 0x8d, 0x91, 0x40, 0x98, 0xab, 0x30, 0xe4, 0xca, 0x12, 0x59, 0x89, 0xed, 0x65, 0x5d, 0x7f, 0xae, 0x69, 0xa0, 0xa4, 0xfa, 0x78, 0xb4, 0xf7, 0xed, 0xae, 0x86, 0x78, 0x79, 0x64, 0x24, 0xa6, 0xd4, 0xe1, 0xf6, 0xd3, 0xa0, 0x89, 0xba, 0x20, 0xf4, 0x54, 0x0d, 0x8f, 0xdb, 0x1a, 0x79, 0xdb},
		subYX: Elt{0xe1, 0x82, 0x0c, 0x4d, 0xde, 0x9f, 0x40, 0xf0, 0xc1, 0xbd, 0x8b, 0xd3, 0x24, 0x03, 0xcd, 0xf2, 0x92, 0x7d, 0xe2, 0x68, 0x7f, 0xf1, 0xbe, 0x69, 0xde, 0x34, 0x67, 0x4c, 0x85, 0x3b, 0xec, 0x98, 0xcc, 0x4d, 0x3e, 0xc0, 0x96, 0x27, 0xe6, 0x75, 0xfc, 0xdf, 0x37, 0xc0, 0x1e, 0x27, 0xe0, 0xf6, 0xc2, 0xbd, 0xbc, 0x3d, 0x9b, 0x39, 0xdc, 0xe2},
		dt2:   Elt{0xd8, 0x29, 0xa7, 0x39, 0xe3, 0x9f, 0x2f, 0x0e, 0x4b, 0x24, 0x21, 0x70, 0xef, 0xfd, 0x91, 0xea, 0xbf, 0xe1, 0x72, 0x90, 0xcc, 0xc9, 0x84, 0x0e, 0xad, 0xd5, 0xe6, 0xbb, 0xc5, 0x99, 0x7f, 0xa4, 0xf0, 0x2e, 0xcc, 0x95, 0x64, 0x27, 0x19, 0xd8, 0x4c, 0x27, 0x0d, 0xff, 0xb6, 0x29, 0xe2, 0x6c, 0xfa, 0xbb, 0x4d, 0x9c, 0xbb, 0xaf, 0xa5, 0xec},
	},
	{ /* 41P*/
		addYX: Elt{0xd6, 0x33, 0x3f, 0x9f, 0xcf, 0xfd, 0x4c, 0xd1, 0xfe, 0xe5, 0xeb, 0x64, 0x27, 0xae, 0x7a, 0xa2, 0x82, 0x50, 0x6d, 0xaa, 0xe3, 0x5d, 0xe2, 0x48, 0x60, 0xb3, 0x76, 0x04, 0xd9, 0x19, 0xa7, 0xa1, 0x73, 0x8d, 0x38, 0xa9, 0xaf, 0x45, 0xb5, 0xb2, 0x62, 0x9b, 0xf1, 0x35, 0x7b, 0x84, 0x66, 0xeb, 0x06, 0xef, 0xf1, 0xb2, 0x2d, 0x6a, 0x61, 0x15},
		subYX: Elt{0x86, 0x50, 0x42, 0xf7, 0xda, 0x59, 0xb2, 0xcf, 0x0d, 0x3d, 0xee, 0x8e, 0x53, 0x5d, 0xf7, 0x9e, 0x6a, 0x26, 0x2d, 0xc7, 0x8c, 0x8e, 0x18, 0x50, 0x6d, 0xb7, 0x51, 0x4c, 0xa7, 0x52, 0x6e, 0x0e, 0x0a, 0x16, 0x74, 0xb2, 0x81, 0x8b, 0x56, 0x27, 0x22, 0x84, 0xf4, 0x56, 0xc5, 0x06, 0xe1, 0x8b, 0xca, 0x2d, 0xdb, 0x9a, 0xf6, 0x10, 0x9c, 0x51},
		dt2:   Elt{0x1f, 0x16, 0xa2, 0x78, 0x96, 0x1b, 0x85, 0x9c, 0x76, 0x49, 0xd4, 0x0f, 0xac, 0xb0, 0xf4, 0xd0, 0x06, 0x2c, 0x7e, 0x6d, 0x6e, 0x8e, 0xc7, 0x9f, 0x18, 0xad, 0xfc, 0x88, 0x0c, 0x0c, 0x09, 0x05, 0x05, 0xa0, 0x79, 0x72, 0x32, 0x72, 0x87, 0x0f, 0x49, 0x87, 0x0c, 0xb4, 0x12, 0xc2, 0x09, 0xf8, 0x9f, 0x30, 0x72, 0xa9, 0x47, 0x13, 0x93, 0x49},
	},
	{ /* 43P*/
		addYX: Elt{0xcc, 0xb1, 0x4c, 0xd3, 0xc0, 0x9e, 0x9e, 0x4d, 0x6d, 0x28, 0x0b, 0xa5, 0x94, 0xa7, 0x2e, 0xc2, 0xc7, 0xaf, 0x29, 0x73, 0xc9, 0x68, 0xea, 0x0f, 0x34, 0x37, 0x8d, 0x96, 0x8f, 0x3a, 0x3d, 0x73, 0x1e, 0x6d, 0x9f, 0xcf, 0x8d, 0x83, 0xb5, 0x71, 0xb9, 0xe1, 0x4b, 0x67, 0x71, 0xea, 0xcf, 0x56, 0xe5, 0xeb, 0x72, 0x15, 0x2f, 0x9e, 0xa8, 0xaa},
		subYX: Elt{0xf4, 0x3e, 0x85, 0x1c, 0x1a, 0xef, 0x50, 0xd1, 0xb4, 0x20, 0xb2, 0x60, 0x05, 0x98, 0xfe, 0x47, 0x3b, 0xc1, 0x76, 0xca, 0x2c, 0x4e, 0x5a, 0x42, 0xa3, 0xf7, 0x20, 0xaa, 0x57, 0x39, 0xee, 0x34, 0x1f, 0xe1, 0x68, 0xd3, 0x7e, 0x06, 0xc4, 0x6c, 0xc7, 0x76, 0x2b, 0xe4, 0x1c, 0x48, 0x44, 0xe6, 0xe5, 0x44, 0x24, 0x8d, 0xb3, 0xb6, 0x88, 0x32},
		dt2:   Elt{0x18, 0xa7, 0xba, 0xd0, 0x44, 0x6f, 0x33, 0x31, 0x00, 0xf8, 0xf6, 0x12, 0xe3, 0xc5, 0xc7, 0xb5, 0x91, 0x9c, 0x91, 0xb5, 0x75, 0x18, 0x18, 0x8a, 0xab, 0xed, 0x24, 0x11, 0x2e, 0xce, 0x5a, 0x0f, 0x94, 0x5f, 0x2e, 0xca, 0xd3, 0x80, 0xea, 0xe5, 0x34, 0x96, 0x67, 0x8b, 0x6a, 0x26, 0x5e, 0xc8, 0x9d, 0x2c, 0x5e, 0x6c, 0xa2, 0x0c, 0xbf, 0xf0},
	},
	{ /* 45P*/
		addYX: Elt{0xb3, 0xbf, 0xa3, 0x85, 0xee, 0xf6, 0x58, 0x02, 0x78, 0xc4, 0x30, 0xd6, 0x57, 0x59, 0x8c, 0x88, 0x08, 0x7c, 0xbc, 0xbe, 0x0a, 0x74, 0xa9, 0xde, 0x69, 0xe7, 0x41, 0xd8, 0xbf, 0x66, 0x8d, 0x3d, 0x28, 0x00, 0x8c, 0x47, 0x65, 0x34, 0xfe, 0x86, 0x9e, 0x6a, 0xf2, 0x41, 0x6a, 0x94, 0xc4, 0x88, 0x75, 0x23, 0x0d, 0x52, 0x69, 0xee, 0x07, 0x89},
		subYX: Elt{0x22, 0x3c, 0xa1, 0x70, 0x58, 0x97, 0x93, 0xbe, 0x59, 0xa8, 0x0b, 0x8a, 0x46, 0x2a, 0x38, 0x1e, 0x08, 0x6b, 0x61, 0x9f, 0xf2, 0x4a, 0x8b, 0x80, 0x68, 0x6e, 0xc8, 0x92, 0x60, 0xf3, 0xc9, 0x89, 0xb2, 0x6d, 0x63, 0xb0, 0xeb, 0x83, 0x15, 0x63, 0x0e, 0x64, 0xbb, 0xb8, 0xfe, 0xb4, 0x81, 0x90, 0x01, 0x28, 0x10, 0xb9, 0x74, 0x6e, 0xde, 0xa4},
		dt2:   Elt{0x1a, 0x23, 0x45, 0xa8, 0x6f, 0x4e, 0xa7, 0x4a, 0x0c, 0xeb, 0xb0, 0x43, 0xf9, 0xef, 0x99, 0x60, 0x5b, 0xdb, 0x66, 0xc0, 0x86, 0x71, 0x43, 0xb1, 0x22, 0x7b, 0x1c, 0xe7, 0x8d, 0x09, 0x1d, 0x83, 0x76, 0x9c, 0xd3, 0x5a, 0xdd, 0x42, 0xd9, 0x2f, 0x2d, 0xba, 0x7a, 0xc2, 0xd9, 0x6b, 0xd4, 0x7a, 0xf1, 0xd5, 0x5f, 0x6b, 0x85, 0xbf, 0x0b, 0xf1},
	},
	{ /* 47P*/
		addYX: Elt{0xb2, 0x83, 0xfa, 0x1f, 0xd2, 0xce, 0xb6, 0xf2, 0x2d, 0xea, 0x1b, 0xe5, 0x29, 0xa5, 0x72, 0xf9, 0x25, 0x48, 0x4e, 0xf2, 0x50, 0x1b, 0x39, 0xda, 0x34, 0xc5, 0x16, 0x13, 0xb4, 0x0c, 0xa1, 0x00, 0x79, 0x7a, 0xf5, 0x8b, 0xf3, 0x70, 0x14, 0xb6, 0xfc, 0x9a, 0x47, 0x68, 0x1e, 0x42, 0x70, 0x64, 0x2a, 0x84, 0x3e, 0x3d, 0x20, 0x58, 0xf9, 0x6a},
		subYX: Elt{0xd9, 0xee, 0xc0, 0xc4, 0xf5, 0xc2, 0x86, 0xaf, 0x45, 0xd2, 0xd2, 0x87, 0x1b, 0x64, 0xd5, 0xe0, 0x8c, 0x44, 0x00, 0x4f, 0x43, 0x89, 0x04, 0x48, 0x4a, 0x0b, 0xca, 0x94, 0x06, 0x2f, 0x23, 0x5b, 0x6c, 0x8d, 0x44, 0x66, 0x53, 0xf5, 0x5a, 0x20, 0x72, 0x28, 0x58, 0x84, 0xcc, 0x73, 0x22, 0x5e, 0xd1, 0x0b, 0x56, 0x5e, 0x6a, 0xa3, 0x11, 0x91},
		dt2:   Elt{0x6e, 0x9f, 0x88, 0xa8, 0x68, 0x2f, 0x12, 0x37, 0x88, 0xfc, 0x92, 0x8f, 0x24, 0xeb, 0x5b, 0x2a, 0x2a, 0xd0, 0x14, 0x40, 0x4c, 0xa9, 0xa4, 0x03, 0x0c, 0x45, 0x48, 0x13, 0xe8, 0xa6, 0x37, 0xab, 0xc0, 0x06, 0x38, 0x6c, 0x96, 0x73, 0x40, 0x6c, 0xc6, 0xea, 0x56, 0xc6, 0xe9, 0x1a, 0x69, 0xeb, 0x7a, 0xd1, 0x33, 0x69, 0x58, 0x2b, 0xea, 0x2f},
	},
	{ /* 49P*/
		addYX: Elt{0x58, 0xa8, 0x05, 0x41, 0x00, 0x9d, 0xaa, 0xd9, 0x98, 0xcf, 0xb9, 0x41, 0xb5, 0x4a, 0x8d, 0xe2, 0xe7, 0xc0, 0x72, 0xef, 0xc8, 0x28, 0x6b, 0x68, 0x9d, 0xc9, 0xdf, 0x05, 0x8b, 0xd0, 0x04, 0x74, 0x79, 0x45, 0x52, 0x05, 0xa3, 0x6e, 0x35, 0x3a, 0xe3, 0xef, 0xb2, 0xdc, 0x08, 0x6f, 0x4e, 0x76, 0x85, 0x67, 0xba, 0x23, 0x8f, 0xdd, 0xaf, 0x09},
		subYX: Elt{0xb4, 0x38, 0xc8, 0xff, 0x4f, 0x65, 0x2a, 0x7e, 0xad, 0xb1, 0xc6, 0xb9, 0x3d, 0xd6, 0xf7, 0x14, 0xcf, 0xf6, 0x98, 0x75, 0xbb, 0x47, 0x83, 0x90, 0xe7, 0xe1, 0xf6, 0x14, 0x99, 0x7e, 0xfa, 0xe4, 0x77, 0x24, 0xe3, 0xe7, 0xf0, 0x1e, 0xdb, 0x27, 0x4e, 0x16, 0x04, 0xf2, 0x08, 0x52, 0xfc, 0xec, 0x55, 0xdb, 0x2e, 0x67, 0xe1, 0x94, 0x32, 0x89},
		dt2:   Elt{0x00, 0xad, 0x03, 0x35, 0x1a, 0xb1, 0x88, 0xf0, 0xc9, 0x11, 0xe4, 0x12, 0x52, 0x61, 0xfd, 0x8a, 0x1b, 0x6a, 0x0a, 0x4c, 0x42, 0x46, 0x22, 0x0e, 0xa5, 0xf9, 0xe2, 0x50, 0xf2, 0xb2, 0x1f, 0x20, 0x78, 0x10, 0xf6, 0xbf, 0x7f, 0x0c, 0x9c, 0xad, 0x40, 0x8b, 0x82, 0xd4, 0xba, 0x69, 0x09, 0xac, 0x4b, 0x6d, 0xc4, 0x49, 0x17, 0x81, 0x57, 0x3b},
	},
	{ /* 51P*/
		addYX: Elt{0x0d, 0xfe, 0xb4, 0x35, 0x11, 0xbd, 0x1d, 0x6b, 0xc2, 0xc5, 0x3b, 0xd2, 0x23, 0x2c, 0x72, 0xe3, 0x48, 0xb1, 0x48, 0x73, 0xfb, 0xa3, 0x21, 0x6e, 0xc0, 0x09, 0x69, 0xac, 0xe1, 0x60, 0xbc, 0x24, 0x03, 0x99, 0x63, 0x0a, 0x00, 0xf0, 0x75, 0xf6, 0x92, 0xc5, 0xd6, 0xdb, 0x51, 0xd4, 0x7d, 0xe6, 0xf4, 0x11, 0x79, 0xd7, 0xc3, 0xaf, 0x48, 0xd0},
		subYX: Elt{0xf4, 0x4f, 0xaf, 0x31, 0xe3, 0x10, 0x89, 0x95, 0xf0, 0x8a, 0xf6, 0x31, 0x9f, 0x48, 0x02, 0xba, 0x42, 0x2b, 0x3c, 0x22, 0x8b, 0xcc, 0x12, 0x98, 0x6e, 0x7a, 0x64, 0x3a, 0xc4, 0xca, 0x32, 0x2a, 0x72, 0xf8, 0x2c, 0xcf, 0x78, 0x5e, 0x7a, 0x75, 0x6e, 0x72, 0x46, 0x48, 0x62, 0x28, 0xac, 0x58, 0x1a, 0xc6, 0x59, 0x88, 0x2a, 0x44, 0x9e, 0x83},
		dt2:   Elt{0xb3, 0xde, 0x36, 0xfd, 0xeb, 0x1b, 0xd4, 0x24, 0x1b, 0x08, 0x8c, 0xfe, 0xa9, 0x41, 0xa1, 0x64, 0xf2, 0x6d, 0xdb, 0xf9, 0x94, 0xae, 0x86, 0x71, 0xab, 0x10, 0xbf, 0xa3, 0xb2, 0xa0, 0xdf, 0x10, 0x8c, 0x74, 0xce, 0xb3, 0xfc, 0xdb, 0xba, 0x15, 0xf6, 0x91, 0x7a, 0x9c, 0x36, 0x1e, 0x45, 0x07, 0x3c, 0xec, 0x1a, 0x61, 0x26, 0x93, 0xe3, 0x50},
	},
	{ /* 53P*/
		addYX: Elt{0xc5, 0x50, 0xc5, 0x83, 0xb0, 0xbd, 0xd9, 0xf6, 0x6d, 0x15, 0x5e, 0xc1, 0x1a, 0x33, 0xa0, 0xce, 0x13, 0x70, 0x3b, 0xe1, 0x31, 0xc6, 0xc4, 0x02, 0xec, 0x8c, 0xd5, 0x9c, 0x97, 0xd3, 0x12, 0xc4, 0xa2, 0xf9, 0xd5, 0xfb, 0x22, 0x69, 0x94, 0x09, 0x2f, 0x59, 0xce, 0xdb, 0xf2, 0xf2, 0x00, 0xe0, 0xa9, 0x08, 0x44, 0x2e, 0x8b, 0x6b, 0xf5, 0xb3},
		subYX: Elt{0x90, 0xdd, 0xec, 0xa2, 0x65, 0xb7, 0x61, 0xbc, 0xaa, 0x70, 0xa2, 0x15, 0xd8, 0xb0, 0xf8, 0x8e, 0x23, 0x3d, 0x9f, 0x46, 0xa3, 0x29, 0x20, 0xd1, 0xa1, 0x15, 0x81, 0xc6, 0xb6, 0xde, 0xbe, 0x60, 0x63, 0x24, 0xac, 0x15, 0xfb, 0xeb, 0xd3, 0xea, 0x57, 0x13, 0x86, 0x38, 0x1e, 0x22, 0xf4, 0x8c, 0x5d, 0xaf, 0x1b, 0x27, 0x21, 0x4f, 0xa3, 0x63},
		dt2:   Elt{0x07, 0x15, 0x87, 0xc4, 0xfd, 0xa1, 0x97, 0x7a, 0x07, 0x1f, 0x56, 0xcc, 0xe3, 0x6a, 0x01, 0x90, 0xce, 0xf9, 0xfa, 0x50, 0xb2, 0xe0, 0x87, 0x8b, 0x6c, 0x63, 0x6c, 0xf6, 0x2a, 0x09, 0xef, 0xef, 0xd2, 0x31, 0x40, 0x25, 0xf6, 0x84, 0xcb, 0xe0, 0xc4, 0x23, 0xc1, 0xcb, 0xe2, 0x02, 0x83, 0x2d, 0xed, 0x74, 0x74, 0x8b, 0xf8, 0x7c, 0x81, 0x18},
	},
	{ /* 55P*/
		addYX: Elt{0x9e, 0xe5, 0x59, 0x95, 0x63, 0x2e, 0xac, 0x8b, 0x03, 0x3c, 0xc1, 0x8e, 0xe1, 0x5b, 0x56, 0x3c, 0x16, 0x41, 0xe4, 0xc2, 0x60, 0x0c, 0x6d, 0x65, 0x9f, 0xfc, 0x27, 0x68, 0x43, 0x44, 0x05, 0x12, 0x6c, 0xda, 0x04, 0xef, 0xcf, 0xcf, 0xdc, 0x0a, 0x1a, 0x7f, 0x12, 0xd3, 0xeb, 0x02, 0xb6, 0x04, 0xca, 0xd6, 0xcb, 0xf0, 0x22, 0xba, 0x35, 0x6d},
		subYX: Elt{0x09, 0x6d, 0xf9, 0x64, 0x4c, 0xe6, 0x41, 0xff, 0x01, 0x4d, 0xce, 0x1e, 0xfa, 0x38, 0xa2, 0x25, 0x62, 0xff, 0x03, 0x39, 0x18, 0x91, 0xbb, 0x9d, 0xce, 0x02, 0xf0, 0xf1, 0x3c, 0x55, 0x18, 0xa9, 0xab, 0x4d, 0xd2, 0x35, 0xfd, 0x8d, 0xa9, 0xb2, 0xad, 0xb7, 0x06, 0x6e, 0xc6, 0x69, 0x49, 0xd6, 0x98, 0x98, 0x0b, 0x22, 0x81, 0x6b, 0xbd, 0xa0},
		dt2:   Elt{0x22, 0xf4, 0x85, 0x5d, 0x2b, 0xf1, 0x55, 0xa5, 0xd6, 0x27, 0x86, 0x57, 0x12, 0x1f, 0x16, 0x0a, 0x5a, 0x9b, 0xf2, 0x38, 0xb6, 0x28, 0xd8, 0x99, 0x0c, 0x89, 0x1d, 0x7f, 0xca, 0x21, 0x17, 0x1a, 0x0b, 0x02, 0x5f, 0x77, 0x2f, 0x73, 0x30, 0x7c, 0xc8, 0xd7, 0x2b, 0xcc, 0xe7, 0xf3, 0x21, 0xac, 0x53, 0xa7, 0x11, 0x5d, 0xd8, 0x1d, 0x9b, 0xf5},
	},
	{ /* 57P*/
		addYX: Elt{0x94, 0x63, 0x5d, 0xef, 0xfd, 0x6d, 0x25, 0x4e, 0x6d, 0x29, 0x03, 0xed, 0x24, 0x28, 0x27, 0x57, 0x47, 0x3e, 0x6a, 0x1a, 0xfe, 0x37, 0xee, 0x5f, 0x83, 0x29, 0x14, 0xfd, 0x78, 0x25, 0x8a, 0xe1, 0x02, 0x38, 0xd8, 0xca, 0x65, 0x55, 0x40, 0x7d, 0x48, 0x2c, 0x7c, 0x7e, 0x60, 0xb6, 0x0c, 0x6d, 0xf7, 0xe8, 0xb3, 0x62, 0x53, 0xd6, 0x9c, 0x2b},
		subYX: Elt{0x47, 0x25, 0x70, 0x62, 0xf5, 0x65, 0x93, 0x62, 0x08, 0xac, 0x59, 0x66, 0xdb, 0x08, 0xd9, 0x1a, 0x19, 0xaf, 0xf4, 0xef, 0x02, 0xa2, 0x78, 0xa9, 0x55, 0x1c, 0xfa, 0x08, 0x11, 0xcb, 0xa3, 0x71, 0x74, 0xb1, 0x62, 0xe7, 0xc7, 0xf3, 0x5a, 0xb5, 0x8b, 0xd4, 0xf6, 0x10, 0x57, 0x79, 0x72, 0x2f, 0x13, 0x86, 0x7b, 0x44, 0x5f, 0x48, 0xfd, 0x88},
		dt2:   Elt{0x10, 0x02, 0xcd, 0x05, 0x9a, 0xc3, 0x32, 0x6d, 0x10, 0x3a, 0x74, 0xba, 0x06, 0xc4, 0x3b, 0x34, 0xbc, 0x36, 0xed, 0xa3, 0xba, 0x9a, 0xdb, 0x6d, 0xd4, 0x69, 0x99, 0x97, 0xd0, 0xe4, 0xdd, 0xf5, 0xd4, 0x7c, 0xd3, 0x4e, 0xab, 0xd1, 0x3b, 0xbb, 0xe9, 0xc7, 0x6a, 0x94, 0x25, 0x61, 0xf0, 0x06, 0xc5, 0x12, 0xa8, 0x86, 0xe5, 0x35, 0x46, 0xeb},
	},
	{ /* 59P*/
		addYX: Elt{0x9e, 0x95, 0x11, 0xc6, 0xc7, 0xe8, 0xee, 0x5a, 0x26, 0xa0, 0x72, 0x72, 0x59, 0x91, 0x59, 0x16, 0x49, 0x99, 0x7e, 0xbb, 0xd7, 0x15, 0xb4, 0xf2, 0x40, 0xf9, 0x5a, 0x4d, 0xc8, 0xa0, 0xe2, 0x34, 0x7b, 0x34, 0xf3, 0x99, 0xbf, 0xa9, 0xf3, 0x79, 0xc1, 0x1a, 0x0c, 0xf4, 0x86, 0x74, 0x4e, 0xcb, 0xbc, 0x90, 0xad, 0xb6, 0x51, 0x6d, 0xaa, 0x33},
		subYX: Elt{0x9f, 0xd1, 0xc5, 0xa2, 0x6c, 0x24, 0x88, 0x15, 0x71, 0x68, 0xf6, 0x07, 0x45, 0x02, 0xc4, 0x73, 0x7e, 0x75, 0x87, 0xca, 0x7c, 0xf0, 0x92, 0x00, 0x75, 0xd6, 0x5a, 0xdd, 0xe0, 0x64, 0x16, 0x9d, 0x62, 0x80, 0x33, 0x9f, 0xf4, 0x8e, 0x1a, 0x15, 0x1c, 0xd3, 0x0f, 0x4d, 0x4f, 0x62, 0x2d, 0xd7, 0xa5, 0x77, 0xe3, 0xea, 0xf0, 0xfb, 0x1a, 0xdb},
		dt2:   Elt{0x6a, 0xa2, 0xb1, 0xaa, 0xfb, 0x5a, 0x32, 0x4e, 0xff, 0x47, 0x06, 0xd5, 0x9a, 0x4f, 0xce, 0x83, 0x5b, 0x82, 0x34, 0x3e, 0x47, 0xb8, 0xf8, 0xe9, 0x7c, 0x67, 0x69, 0x8d, 0x9c, 0xb7, 0xde, 0x57, 0xf4, 0x88, 0x41, 0x56, 0x0c, 0x87, 0x1e, 0xc9, 0x2f, 0x54, 0xbf, 0x5c, 0x68, 0x2c, 0xd9, 0xc4, 0xef, 0x53, 0x73, 0x1e, 0xa6, 0x38, 0x02, 0x10},
	},
	{ /* 61P*/
		addYX: Elt{0x08, 0x80, 0x4a, 0xc9, 0xb7, 0xa8, 0x88, 0xd9, 0xfc, 0x6a, 0xc0, 0x3e, 0xc2, 0x33, 0x4d, 0x2b, 0x2a, 0xa3, 0x6d, 0x72, 0x3e, 0xdc, 0x34, 0x68, 0x08, 0xbf, 0x27, 0xef, 0xf4, 0xff, 0xe2, 0x0c, 0x31, 0x0c, 0xa2, 0x0a, 0x1f, 0x65, 0xc1, 0x4c, 0x61, 0xd3, 0x1b, 0xbc, 0x25, 0xb1, 0xd0, 0xd4, 0x89, 0xb2, 0x53, 0xfb, 0x43, 0xa5, 0xaf, 0x04},
		subYX: Elt{0xe3, 0xe1, 0x37, 0xad, 0x58, 0xa9, 0x55, 0x81, 0xee, 0x64, 0x21, 0xb9, 0xf5, 0x4c, 0x35, 0xea, 0x4a, 0xd3, 0x26, 0xaa, 0x90, 0xd4, 0x60, 0x46, 0x09, 0x4b, 0x4a, 0x62, 0xf9, 0xcd, 0xe1, 0xee, 0xbb, 0xc2, 0x09, 0x0b, 0xb0, 0x96, 0x8e, 0x43, 0x77, 0xaf, 0x25, 0x20, 0x5e, 0x47, 0xe4, 0x1d, 0x50, 0x69, 0x74, 0x08, 0xd7, 0xb9, 0x90, 0x13},
		dt2:   Elt{0x51, 0x91, 0x95, 0x64, 0x03, 0x16, 0xfd, 0x6e, 0x26, 0x94, 0x6b, 0x61, 0xe7, 0xd9, 0xe0, 0x4a, 0x6d, 0x7c, 0xfa, 0xc0, 0xe2, 0x43, 0x23, 0x53, 0x70, 0xf5, 0x6f, 0x73, 0x8b, 0x81, 0xb0, 0x0c, 0xee, 0x2e, 0x46, 0xf2, 0x8d, 0xa6, 0xfb, 0xb5, 0x1c, 0x33, 0xbf, 0x90, 0x59, 0xc9, 0x7c, 0xb8, 0x6f, 0xad, 0x75, 0x02, 0x90, 0x8e, 0x59, 0x75},
	},
	{ /* 63P*/
		addYX: Elt{0x36, 0x4d, 0x77, 0x04, 0xb8, 0x7d, 0x4a, 0xd1, 0xc5, 0xbb, 0x7b, 0x50, 0x5f, 0x8d, 0x9d, 0x62, 0x0f, 0x66, 0x71, 0xec, 0x87, 0xc5, 0x80, 0x82, 0xc8, 0xf4, 0x6a, 0x94, 0x92, 0x5b, 0xb0, 0x16, 0x9b, 0xb2, 0xc9, 0x6f, 0x2b, 0x2d, 0xee, 0x95, 0x73, 0x2e, 0xc2, 0x1b, 0xc5, 0x55, 0x36, 0x86, 0x24, 0xf8, 0x20, 0x05, 0x0d, 0x93, 0xd7, 0x76},
		subYX: Elt{0x7f, 0x01, 0xeb, 0x2e, 0x48, 0x4d, 0x1d, 0xf1, 0x06, 0x7e, 0x7c, 0x2a, 0x43, 0xbf, 0x28, 0xac, 0xe9, 0x58, 0x13, 0xc8, 0xbf, 0x8e, 0xc0, 0xef, 0xe8, 0x4f, 0x46, 0x8a, 0xe7, 0xc0, 0xf6, 0x0f, 0x0a, 0x03, 0x48, 0x91, 0x55, 0x39, 0x2a, 0xe3, 0xdc, 0xf6, 0x22, 0x9d, 0x4d, 0x71, 0x55, 0x68, 0x25, 0x6e, 0x95, 0x52, 0xee, 0x4c, 0xd9, 0x01},
		dt2:   Elt{0xac, 0x33, 0x3f, 0x7c, 0x27, 0x35, 0x15, 0x91, 0x33, 0x8d, 0xf9, 0xc4, 0xf4, 0xf3, 0x90, 0x09, 0x75, 0x69, 0x62, 0x9f, 0x61, 0x35, 0x83, 0x92, 0x04, 0xef, 0x96, 0x38, 0x80, 0x9e, 0x88, 0xb3, 0x67, 0x95, 0xbe, 0x79, 0x3c, 0x35, 0xd8, 0xdc, 0xb2, 0x3e, 0x2d, 0xe6, 0x46, 0xbe, 0x81, 0xf3, 0x32, 0x0e, 0x37, 0x23, 0x75, 0x2a, 0x3d, 0xa0},
	},
}

// p is the prime modulus 2^448-2^224-1.
var p = Elt{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

// P returns the prime modulus 2^448-2^224-1.
func PMod() Elt {
	return Elt{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}
}

// ToBytes stores in b the little-endian byte representation of x.
func ToBytes(b []byte, x Elt) string {
	if len(b) != 56 {
		return "wrong size"
	}
	Modp(x)
	copy(b, x[:])
	return ""
}

// IsZero returns true if x is equal to 0.
func EltIsZero(x Elt) bool {
	Modp(x)
	return x[0] == 0 && x[1] == 0 && x[2] == 0 && x[3] == 0 && x[4] == 0 && x[5] == 0 && x[6] == 0 && x[7] == 0 && x[8] == 0 && x[9] == 0 && x[10] == 0 && x[11] == 0 && x[12] == 0 && x[13] == 0 && x[14] == 0 && x[15] == 0 && x[16] == 0 && x[17] == 0 && x[18] == 0 && x[19] == 0 && x[20] == 0 && x[21] == 0 && x[22] == 0 && x[23] == 0 && x[24] == 0 && x[25] == 0 && x[26] == 0 && x[27] == 0 && x[28] == 0 && x[29] == 0 && x[30] == 0 && x[41] == 0 && x[42] == 0 && x[43] == 0 && x[44] == 0 && x[45] == 0 && x[46] == 0 && x[47] == 0 && x[48] == 0 && x[49] == 0 && x[50] == 0 && x[51] == 0 && x[52] == 0 && x[53] == 0 && x[54] == 0 && x[55] == 0
}

// IsOne returns true if x is equal to 1.
func IsOne(x Elt) bool {
	Modp(x)
	return x == Elt{1}
}

// SetOne assigns x=1.
func SetOne(x *Elt) {
	*x = Elt{1}
}

// One returns the 1 element.
func One() Elt {
	x := Elt{1}
	return x
}

// Neg calculates z = -x.
func EltNeg(z, x Elt) {
	EltSub(z, p, x)
}

// Modp ensures that z is between [0,p-1].
func Modp(z Elt) {
	p := Elt{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}
	EltSub(z, z, p)
}

// InvSqrt calculates z = sqrt(x/y) iff x/y is a quadratic-residue. If so,
// isQR = true; otherwise, isQR = false, since x/y is a quadratic non-residue,
// and z = sqrt(-x/y).
func InvSqrt(z, x, y Elt) (isQR bool) {
	// First note that x^(2(k+1)) = x^(p-1)/2 * x = legendre(x) * x
	// so that's x if x is a quadratic residue and -x otherwise.
	// Next, y^(6k+3) = y^(4k+2) * y^(2k+1) = y^(p-1) * y^((p-1)/2) = legendre(y).
	// So the z we compute satisfies z^2 y = x^(2(k+1)) y^(6k+3) = legendre(x)*legendre(y).
	// Thus if x and y are quadratic residues, then z is indeed sqrt(x/y).
	t0, t1 := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	EltMul(t0, x, y)      // x*y
	EltSqr(t1, y)         // y^2
	EltMul(t1, t0, t1)    // x*y^3
	powPminus3div4(z, t1) // (x*y^3)^k
	EltMul(z, z, t0)      // z = x*y*(x*y^3)^k = x^(k+1) * y^(3k+1)

	// Check if x/y is a quadratic residue
	EltSqr(t0, z)     // z^2
	EltMul(t0, t0, y) // y*z^2
	EltSub(t0, t0, x) // y*z^2-x
	return EltIsZero(t0)
}

// Inv calculates z = 1/x mod p.
func EltInv(z, x Elt) {
	// Calculates z = x^(4k+1) = x^(p-3+1) = x^(p-2) = x^-1, where k = (p-3)/4.
	t := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	powPminus3div4(t, x) // t = x^k
	EltSqr(t, t)         // t = x^2k
	EltSqr(t, t)         // t = x^4k
	EltMul(z, t, x)      // z = x^(4k+1)
}

// powPminus3div4 calculates z = x^k mod p, where k = (p-3)/4.
func powPminus3div4(z, x Elt) {
	x0, x1 := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	EltSqr(z, x)
	EltMul(z, z, x)
	EltSqr(x0, z)
	EltMul(x0, x0, x)
	EltSqr(z, x0)
	EltSqr(z, z)
	EltSqr(z, z)
	EltMul(z, z, x0)
	EltSqr(x1, z)
	for i := 0; i < 5; i++ {
		EltSqr(x1, x1)
	}
	EltMul(x1, x1, z)
	EltSqr(z, x1)
	for i := 0; i < 11; i++ {
		EltSqr(z, z)
	}
	EltMul(z, z, x1)
	EltSqr(z, z)
	EltSqr(z, z)
	EltSqr(z, z)
	EltMul(z, z, x0)
	EltSqr(x1, z)
	for i := 0; i < 26; i++ {
		EltSqr(x1, x1)
	}
	EltMul(x1, x1, z)
	EltSqr(z, x1)
	for i := 0; i < 53; i++ {
		EltSqr(z, z)
	}
	EltMul(z, z, x1)
	EltSqr(z, z)
	EltSqr(z, z)
	EltSqr(z, z)
	EltMul(z, z, x0)
	EltSqr(x1, z)
	for i := 0; i < 110; i++ {
		EltSqr(x1, x1)
	}
	EltMul(x1, x1, z)
	EltSqr(z, x1)
	EltMul(z, z, x)
	for i := 0; i < 223; i++ {
		EltSqr(z, z)
	}
	EltMul(z, z, x1)
}

// Cmov assigns y to x if n is 1.
func EltCmov(x, y Elt, n uint) {
	eltcmov(x, y, n)
}

// Cswap interchanges x and y if n is 1.
func EltCswap(x, y Elt, n uint) {
	eltcswap(x, y, n)
}

// Add calculates z = x+y mod p.
func EltAdd(z, x, y Elt) {
	eltfpadd(z, x, y)
}

// Sub calculates z = x-y mod p.
func EltSub(z, x, y Elt) {
	eltfpsub(z, x, y)
}

// AddSub calculates (x,y) = (x+y mod p, x-y mod p).
func EltAddSub(x, y Elt) {
	eltaddsub(x, y)
}

// Mul calculates z = x*y mod p.
func EltMul(z, x, y Elt) {
	eltmul(z, x, y)
}

// Sqr calculates z = x^2 mod p.
func EltSqr(z, x Elt) {
	eltsqr(z, x)
}

func cmovGeneric(x, y Elt, n uint) {
	m := -uint64(n & 0x1)
	x0 := binary.LittleEndianUint64(x[0*8 : 1*8])
	x1 := binary.LittleEndianUint64(x[1*8 : 2*8])
	x2 := binary.LittleEndianUint64(x[2*8 : 3*8])
	x3 := binary.LittleEndianUint64(x[3*8 : 4*8])
	x4 := binary.LittleEndianUint64(x[4*8 : 5*8])
	x5 := binary.LittleEndianUint64(x[5*8 : 6*8])
	x6 := binary.LittleEndianUint64(x[6*8 : 7*8])

	y0 := binary.LittleEndianUint64(y[0*8 : 1*8])
	y1 := binary.LittleEndianUint64(y[1*8 : 2*8])
	y2 := binary.LittleEndianUint64(y[2*8 : 3*8])
	y3 := binary.LittleEndianUint64(y[3*8 : 4*8])
	y4 := binary.LittleEndianUint64(y[4*8 : 5*8])
	y5 := binary.LittleEndianUint64(y[5*8 : 6*8])
	y6 := binary.LittleEndianUint64(y[6*8 : 7*8])

	x0 = (x0 &^ m) | (y0 & m)
	x1 = (x1 &^ m) | (y1 & m)
	x2 = (x2 &^ m) | (y2 & m)
	x3 = (x3 &^ m) | (y3 & m)
	x4 = (x4 &^ m) | (y4 & m)
	x5 = (x5 &^ m) | (y5 & m)
	x6 = (x6 &^ m) | (y6 & m)

	binary.LittleEndianPutUint64(x[0*8:1*8], x0)
	binary.LittleEndianPutUint64(x[1*8:2*8], x1)
	binary.LittleEndianPutUint64(x[2*8:3*8], x2)
	binary.LittleEndianPutUint64(x[3*8:4*8], x3)
	binary.LittleEndianPutUint64(x[4*8:5*8], x4)
	binary.LittleEndianPutUint64(x[5*8:6*8], x5)
	binary.LittleEndianPutUint64(x[6*8:7*8], x6)
}

func cswapGeneric(x, y Elt, n uint) {
	m := -uint64(n & 0x1)
	x0 := binary.LittleEndianUint64(x[0*8 : 1*8])
	x1 := binary.LittleEndianUint64(x[1*8 : 2*8])
	x2 := binary.LittleEndianUint64(x[2*8 : 3*8])
	x3 := binary.LittleEndianUint64(x[3*8 : 4*8])
	x4 := binary.LittleEndianUint64(x[4*8 : 5*8])
	x5 := binary.LittleEndianUint64(x[5*8 : 6*8])
	x6 := binary.LittleEndianUint64(x[6*8 : 7*8])

	y0 := binary.LittleEndianUint64(y[0*8 : 1*8])
	y1 := binary.LittleEndianUint64(y[1*8 : 2*8])
	y2 := binary.LittleEndianUint64(y[2*8 : 3*8])
	y3 := binary.LittleEndianUint64(y[3*8 : 4*8])
	y4 := binary.LittleEndianUint64(y[4*8 : 5*8])
	y5 := binary.LittleEndianUint64(y[5*8 : 6*8])
	y6 := binary.LittleEndianUint64(y[6*8 : 7*8])

	t0 := m & (x0 ^ y0)
	t1 := m & (x1 ^ y1)
	t2 := m & (x2 ^ y2)
	t3 := m & (x3 ^ y3)
	t4 := m & (x4 ^ y4)
	t5 := m & (x5 ^ y5)
	t6 := m & (x6 ^ y6)
	x0 ^= t0
	x1 ^= t1
	x2 ^= t2
	x3 ^= t3
	x4 ^= t4
	x5 ^= t5
	x6 ^= t6
	y0 ^= t0
	y1 ^= t1
	y2 ^= t2
	y3 ^= t3
	y4 ^= t4
	y5 ^= t5
	y6 ^= t6

	binary.LittleEndianPutUint64(x[0*8:1*8], x0)
	binary.LittleEndianPutUint64(x[1*8:2*8], x1)
	binary.LittleEndianPutUint64(x[2*8:3*8], x2)
	binary.LittleEndianPutUint64(x[3*8:4*8], x3)
	binary.LittleEndianPutUint64(x[4*8:5*8], x4)
	binary.LittleEndianPutUint64(x[5*8:6*8], x5)
	binary.LittleEndianPutUint64(x[6*8:7*8], x6)

	binary.LittleEndianPutUint64(y[0*8:1*8], y0)
	binary.LittleEndianPutUint64(y[1*8:2*8], y1)
	binary.LittleEndianPutUint64(y[2*8:3*8], y2)
	binary.LittleEndianPutUint64(y[3*8:4*8], y3)
	binary.LittleEndianPutUint64(y[4*8:5*8], y4)
	binary.LittleEndianPutUint64(y[5*8:6*8], y5)
	binary.LittleEndianPutUint64(y[6*8:7*8], y6)
}

func addGeneric(z, x, y Elt) {
	x0 := binary.LittleEndianUint64(x[0*8 : 1*8])
	x1 := binary.LittleEndianUint64(x[1*8 : 2*8])
	x2 := binary.LittleEndianUint64(x[2*8 : 3*8])
	x3 := binary.LittleEndianUint64(x[3*8 : 4*8])
	x4 := binary.LittleEndianUint64(x[4*8 : 5*8])
	x5 := binary.LittleEndianUint64(x[5*8 : 6*8])
	x6 := binary.LittleEndianUint64(x[6*8 : 7*8])

	y0 := binary.LittleEndianUint64(y[0*8 : 1*8])
	y1 := binary.LittleEndianUint64(y[1*8 : 2*8])
	y2 := binary.LittleEndianUint64(y[2*8 : 3*8])
	y3 := binary.LittleEndianUint64(y[3*8 : 4*8])
	y4 := binary.LittleEndianUint64(y[4*8 : 5*8])
	y5 := binary.LittleEndianUint64(y[5*8 : 6*8])
	y6 := binary.LittleEndianUint64(y[6*8 : 7*8])

	z0, c0 := bits.Add64(x0, y0, 0)
	z1, c1 := bits.Add64(x1, y1, c0)
	z2, c2 := bits.Add64(x2, y2, c1)
	z3, c3 := bits.Add64(x3, y3, c2)
	z4, c4 := bits.Add64(x4, y4, c3)
	z5, c5 := bits.Add64(x5, y5, c4)
	z6, z7 := bits.Add64(x6, y6, c5)

	z0, c0 = bits.Add64(z0, z7, 0)
	z1, c1 = bits.Add64(z1, 0, c0)
	z2, c2 = bits.Add64(z2, 0, c1)
	z3, c3 = bits.Add64(z3, z7<<32, c2)
	z4, c4 = bits.Add64(z4, 0, c3)
	z5, c5 = bits.Add64(z5, 0, c4)
	z6, z7 = bits.Add64(z6, 0, c5)

	z0, c0 = bits.Add64(z0, z7, 0)
	z1, c1 = bits.Add64(z1, 0, c0)
	z2, c2 = bits.Add64(z2, 0, c1)
	z3, c3 = bits.Add64(z3, z7<<32, c2)
	z4, c4 = bits.Add64(z4, 0, c3)
	z5, c5 = bits.Add64(z5, 0, c4)
	z6, _ = bits.Add64(z6, 0, c5)

	binary.LittleEndianPutUint64(z[0*8:1*8], z0)
	binary.LittleEndianPutUint64(z[1*8:2*8], z1)
	binary.LittleEndianPutUint64(z[2*8:3*8], z2)
	binary.LittleEndianPutUint64(z[3*8:4*8], z3)
	binary.LittleEndianPutUint64(z[4*8:5*8], z4)
	binary.LittleEndianPutUint64(z[5*8:6*8], z5)
	binary.LittleEndianPutUint64(z[6*8:7*8], z6)
}

func subGeneric(z, x, y Elt) {
	x0 := binary.LittleEndianUint64(x[0*8 : 1*8])
	x1 := binary.LittleEndianUint64(x[1*8 : 2*8])
	x2 := binary.LittleEndianUint64(x[2*8 : 3*8])
	x3 := binary.LittleEndianUint64(x[3*8 : 4*8])
	x4 := binary.LittleEndianUint64(x[4*8 : 5*8])
	x5 := binary.LittleEndianUint64(x[5*8 : 6*8])
	x6 := binary.LittleEndianUint64(x[6*8 : 7*8])

	y0 := binary.LittleEndianUint64(y[0*8 : 1*8])
	y1 := binary.LittleEndianUint64(y[1*8 : 2*8])
	y2 := binary.LittleEndianUint64(y[2*8 : 3*8])
	y3 := binary.LittleEndianUint64(y[3*8 : 4*8])
	y4 := binary.LittleEndianUint64(y[4*8 : 5*8])
	y5 := binary.LittleEndianUint64(y[5*8 : 6*8])
	y6 := binary.LittleEndianUint64(y[6*8 : 7*8])

	z0, c0 := bits.Sub64(x0, y0, 0)
	z1, c1 := bits.Sub64(x1, y1, c0)
	z2, c2 := bits.Sub64(x2, y2, c1)
	z3, c3 := bits.Sub64(x3, y3, c2)
	z4, c4 := bits.Sub64(x4, y4, c3)
	z5, c5 := bits.Sub64(x5, y5, c4)
	z6, z7 := bits.Sub64(x6, y6, c5)

	z0, c0 = bits.Sub64(z0, z7, 0)
	z1, c1 = bits.Sub64(z1, 0, c0)
	z2, c2 = bits.Sub64(z2, 0, c1)
	z3, c3 = bits.Sub64(z3, z7<<32, c2)
	z4, c4 = bits.Sub64(z4, 0, c3)
	z5, c5 = bits.Sub64(z5, 0, c4)
	z6, z7 = bits.Sub64(z6, 0, c5)

	z0, c0 = bits.Sub64(z0, z7, 0)
	z1, c1 = bits.Sub64(z1, 0, c0)
	z2, c2 = bits.Sub64(z2, 0, c1)
	z3, c3 = bits.Sub64(z3, z7<<32, c2)
	z4, c4 = bits.Sub64(z4, 0, c3)
	z5, c5 = bits.Sub64(z5, 0, c4)
  var qq uint64
	z6, qq = bits.Sub64(z6, 0, c5)

	binary.LittleEndianPutUint64(z[0*8:1*8], z0)
	binary.LittleEndianPutUint64(z[1*8:2*8], z1)
	binary.LittleEndianPutUint64(z[2*8:3*8], z2)
	binary.LittleEndianPutUint64(z[3*8:4*8], z3)
	binary.LittleEndianPutUint64(z[4*8:5*8], z4)
	binary.LittleEndianPutUint64(z[5*8:6*8], z5)
	binary.LittleEndianPutUint64(z[6*8:7*8], z6)
}

func addsubGeneric(x, y Elt) {
	z := Elt{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	addGeneric(z, x, y)
	subGeneric(y, x, y)
	copy(x, z)
}

func mulGeneric(z, x, y Elt) {
	x0 := binary.LittleEndianUint64(x[0*8 : 1*8])
	x1 := binary.LittleEndianUint64(x[1*8 : 2*8])
	x2 := binary.LittleEndianUint64(x[2*8 : 3*8])
	x3 := binary.LittleEndianUint64(x[3*8 : 4*8])
	x4 := binary.LittleEndianUint64(x[4*8 : 5*8])
	x5 := binary.LittleEndianUint64(x[5*8 : 6*8])
	x6 := binary.LittleEndianUint64(x[6*8 : 7*8])

	y0 := binary.LittleEndianUint64(y[0*8 : 1*8])
	y1 := binary.LittleEndianUint64(y[1*8 : 2*8])
	y2 := binary.LittleEndianUint64(y[2*8 : 3*8])
	y3 := binary.LittleEndianUint64(y[3*8 : 4*8])
	y4 := binary.LittleEndianUint64(y[4*8 : 5*8])
	y5 := binary.LittleEndianUint64(y[5*8 : 6*8])
	y6 := binary.LittleEndianUint64(y[6*8 : 7*8])

	yy := [7]uint64{y0, y1, y2, y3, y4, y5, y6}
	zz := [7]uint64{0,0,0,0,0,0,0}

	yi := yy[0]
	h0, l0 := bits.Mul64(x0, yi)
	h1, l1 := bits.Mul64(x1, yi)
	h2, l2 := bits.Mul64(x2, yi)
	h3, l3 := bits.Mul64(x3, yi)
	h4, l4 := bits.Mul64(x4, yi)
	h5, l5 := bits.Mul64(x5, yi)
	h6, l6 := bits.Mul64(x6, yi)

	zz[0] = l0
	a0, c0 := bits.Add64(h0, l1, 0)
	a1, c1 := bits.Add64(h1, l2, c0)
	a2, c2 := bits.Add64(h2, l3, c1)
	a3, c3 := bits.Add64(h3, l4, c2)
	a4, c4 := bits.Add64(h4, l5, c3)
	a5, c5 := bits.Add64(h5, l6, c4)
	a6, _ := bits.Add64(h6, 0, c5)

	for i := 1; i < 7; i++ {
		yi = yy[i]
		h0, l0 = bits.Mul64(x0, yi)
		h1, l1 = bits.Mul64(x1, yi)
		h2, l2 = bits.Mul64(x2, yi)
		h3, l3 = bits.Mul64(x3, yi)
		h4, l4 = bits.Mul64(x4, yi)
		h5, l5 = bits.Mul64(x5, yi)
		h6, l6 = bits.Mul64(x6, yi)

		zz[i], c0 = bits.Add64(a0, l0, 0)
		a0, c1 = bits.Add64(a1, l1, c0)
		a1, c2 = bits.Add64(a2, l2, c1)
		a2, c3 = bits.Add64(a3, l3, c2)
		a3, c4 = bits.Add64(a4, l4, c3)
		a4, c5 = bits.Add64(a5, l5, c4)
		a5, a6 = bits.Add64(a6, l6, c5)

		a0, c0 = bits.Add64(a0, h0, 0)
		a1, c1 = bits.Add64(a1, h1, c0)
		a2, c2 = bits.Add64(a2, h2, c1)
		a3, c3 = bits.Add64(a3, h3, c2)
		a4, c4 = bits.Add64(a4, h4, c3)
		a5, c5 = bits.Add64(a5, h5, c4)
		a6, _ = bits.Add64(a6, h6, c5)
	}
	red64(z, zz, [7]uint64{a0, a1, a2, a3, a4, a5, a6})
}

func sqrGeneric(z, x Elt) { mulGeneric(z, x, x) }

func red64(z Elt, l, h [7]uint64) {
	/* (2C13, 2C12, 2C11, 2C10|C10, C9, C8, C7) + (C6,...,C0) */
	h0 := h[0]
	h1 := h[1]
	h2 := h[2]
	h3 := ((h[3] & (uint64(0xFFFFFFFF) << 32)) << 1) | (h[3] & 0xFFFFFFFF)
	h4 := (h[3] >> 63) | (h[4] << 1)
	h5 := (h[4] >> 63) | (h[5] << 1)
	h6 := (h[5] >> 63) | (h[6] << 1)
	h7 := (h[6] >> 63)

	l0, c0 := bits.Add64(h0, l[0], 0)
	l1, c1 := bits.Add64(h1, l[1], c0)
	l2, c2 := bits.Add64(h2, l[2], c1)
	l3, c3 := bits.Add64(h3, l[3], c2)
	l4, c4 := bits.Add64(h4, l[4], c3)
	l5, c5 := bits.Add64(h5, l[5], c4)
	l6, c6 := bits.Add64(h6, l[6], c5)
	l7, _ := bits.Add64(h7, 0, c6)

	/* (C10C9, C9C8,C8C7,C7C13,C13C12,C12C11,C11C10) + (C6,...,C0) */
	h0 = (h[3] >> 32) | (h[4] << 32)
	h1 = (h[4] >> 32) | (h[5] << 32)
	h2 = (h[5] >> 32) | (h[6] << 32)
	h3 = (h[6] >> 32) | (h[0] << 32)
	h4 = (h[0] >> 32) | (h[1] << 32)
	h5 = (h[1] >> 32) | (h[2] << 32)
	h6 = (h[2] >> 32) | (h[3] << 32)

	l0, c0 = bits.Add64(l0, h0, 0)
	l1, c1 = bits.Add64(l1, h1, c0)
	l2, c2 = bits.Add64(l2, h2, c1)
	l3, c3 = bits.Add64(l3, h3, c2)
	l4, c4 = bits.Add64(l4, h4, c3)
	l5, c5 = bits.Add64(l5, h5, c4)
	l6, c6 = bits.Add64(l6, h6, c5)
	l7, _ = bits.Add64(l7, 0, c6)

	/* (C7) + (C6,...,C0) */
	l0, c0 = bits.Add64(l0, l7, 0)
	l1, c1 = bits.Add64(l1, 0, c0)
	l2, c2 = bits.Add64(l2, 0, c1)
	l3, c3 = bits.Add64(l3, l7<<32, c2)
	l4, c4 = bits.Add64(l4, 0, c3)
	l5, c5 = bits.Add64(l5, 0, c4)
	l6, l7 = bits.Add64(l6, 0, c5)

	/* (C7) + (C6,...,C0) */
	l0, c0 = bits.Add64(l0, l7, 0)
	l1, c1 = bits.Add64(l1, 0, c0)
	l2, c2 = bits.Add64(l2, 0, c1)
	l3, c3 = bits.Add64(l3, l7<<32, c2)
	l4, c4 = bits.Add64(l4, 0, c3)
	l5, c5 = bits.Add64(l5, 0, c4)
	l6, _ = bits.Add64(l6, 0, c5)

	binary.LittleEndianPutUint64(z[0*8:1*8], l0)
	binary.LittleEndianPutUint64(z[1*8:2*8], l1)
	binary.LittleEndianPutUint64(z[2*8:3*8], l2)
	binary.LittleEndianPutUint64(z[3*8:4*8], l3)
	binary.LittleEndianPutUint64(z[4*8:5*8], l4)
	binary.LittleEndianPutUint64(z[5*8:6*8], l5)
	binary.LittleEndianPutUint64(z[6*8:7*8], l6)
}

const (
	// MLSBRecoding parameters
	fxT   = 448
	fxV   = 2
	fxW   = 3
	fx2w1 = 4 // 1 << (uint(fxW) - 1)
)

// ScalarBaseMult returns kG where G is the generator point.
func twistCurveScalarBaseMult(e twistCurve, k *Scalar) *twistPoint {
	m, err := New(fxT, fxV, fxW)
	if err != nil {
		return &twistPoint{}
	}
	if IsExtended(m) {
		return &twistPoint{}
	}

	var isZero int
	if IsZero(k) {
		isZero = 1
	}
	subtle.ConstantTimeCopy(isZero, k[:], order[:])

	minusK := *k
	isEven := 1 - int(k[0]&0x1)
	minusK.Neg()
	subtle.ConstantTimeCopy(isEven, k[:], minusK[:])
	c, err := m.Encode(k[:])
	if err != nil {
		return &twistPoint{}
	}

	gP := c.Exp(groupMLSB{})
	cneg(gP, uint(isEven))
	return gP
}

type groupMLSB struct{}

func (e groupMLSB) ExtendedEltP() EltP {
	return Eltp{}
}

func (e groupMLSB) Sqr(x EltG) {
	Double(x)
}

func (e groupMLSB) Mul(x EltG, y EltP) {
	mixAddZ1(x, y)
}

func (e groupMLSB) Identity() EltG {
	return twistCurveIdentity(twistCurve{})
}

func (e groupMLSB) NewEltP() EltP {
	return &preTwistPointAffine{}
}

func (e groupMLSB) Lookup(a EltP, v uint, s, u int32) {
	Tabj := &tabFixMult[v]
	for k := 0; k < len(Tabj); k++ {
		cmov(a, &Tabj[k], uint(subtle.ConstantTimeEq(int32(k), u)))
	}
	cneg(a, int(s>>31))
}

// // Params contains the parameters of the encoding.
// type Params struct {
// 	T uint // T is the maximum size (in bits) of exponents.
// 	V uint // V is the number of tables.
// 	W uint // W is the window size.
// 	E uint // E is the number of digits per table.
// 	D uint // D is the number of digits in total.
// 	L uint // L is the length of the code.
// }

// // Encoder allows to convert integers into valid powers.
// type Encoder struct{ p Params }

// // New produces an encoder of the MLSBSet algorithm.
// func New(t, v, w uint) (Encoder, error) {
// 	if !(t > 1 && v >= 1 && w >= 2) {
// 		return Encoder{}, errors.New("t>1, v>=1, w>=2")
// 	}
// 	e := (t + w*v - 1) / (w * v)
// 	d := e * v
// 	l := d * w
// 	return Encoder{Params{t, v, w, e, d, l}}, nil
// }

// // Encode converts an odd integer k into a valid power for exponentiation.
// func Encode(m Encoder, k []byte) (*Power, error) {
// 	if len(k) == 0 {
// 		return nil, errors.New("empty slice")
// 	}
// 	p := m.p
// 	if !(len(k) <= int(p.L+7)>>3) {
// 		return nil, errors.New("k too big")
// 	}
// 	if k[0]%2 == 0 {
// 		return nil, errors.New("k must be odd")
// 	}
// 	ap := int((p.L+7)/8) - len(k)

// 	q := make([]byte, ap)
// 	for i := 0; i < len(q); i++ {
// 		k = append(k, q[i])
// 	}
// 	s := m.signs(k)
// 	b := make([]int32, p.L-p.D)
// 	c := BytesLe2BigInt(k)
// 	c.Rsh(c, p.D)
// 	var bi big.Int
// 	for i := p.D; i < p.L; i++ {
// 		c0 := int32(c.Bit(0))
// 		b[i-p.D] = s[i%p.D] * c0
// 		bi.SetInt64(int64(b[i-p.D] >> 1))
// 		c.Rsh(c, 1)
// 		c.Sub(c, &bi)
// 	}
// 	carry := int(c.Int64())
// 	return &Power{m, s, b, carry}, nil
// }

// // signs calculates the set of signs.
// func signs(m Encoder, k []byte) []int32 {
// 	p := m.p
// 	s := make([]int32, p.D)
// 	s[p.D-1] = 1
// 	for i := uint(1); i < p.D; i++ {
// 		ki := int32((k[i>>3] >> (i & 0x7)) & 0x1)
// 		s[i-1] = 2*ki - 1
// 	}
// 	return s
// }

// // tableSize returns the size of each table.
// func tableSize(m Encoder) uint {
// 	p := m.p
// 	return 1 << (p.W - 1)
// }

// // Elts returns the total number of elements that must be precomputed.
// func Elts(m Encoder) uint {
// 	p := m.p
// 	return p.V * tableSize(m)
// }

// // IsExtended returns true if the element x^(2^(wd)) must be calculated.
// func IsExtended(m Encoder) bool {
// 	p := m.p
// 	q := p.T / (p.V * p.W)
// 	return p.T == q*p.V*p.W
// }

// // Ops returns the number of squares and multiplications executed during an exponentiation.
// func Ops(m Encoder) (S uint, M uint) {
// 	p := m.p
// 	S = p.E
// 	M = p.E * p.V
// 	if IsExtended(m) {
// 		M++
// 	}
// 	return
// }

// // SignedDigit obtains the signed-digit recoding of n and returns a list L of
// // digits such that n = sum( L[i]*2^(i*(w-1)) ), and each L[i] is an odd number
// // in the set {±1, ±3, ..., ±2^(w-1)-1}. The third parameter ensures that the
// // output has ceil(l/(w-1)) digits.
// //
// // Restrictions:
// //   - n is odd and n > 0.
// //   - 1 < w < 32.
// //   - l >= bit length of n.
// //
// // References:
// //   - Alg.6 in "Exponent Recoding and Regular Exponentiation Algorithms"
// //     by Joye-Tunstall. http://doi.org/10.1007/978-3-642-02384-2_21
// //   - Alg.6 in "Selecting Elliptic Curves for Cryptography: An Efficiency and
// //     Security Analysis" by Bos et al. http://doi.org/10.1007/s13389-015-0097-y
// func SignedDigit(n *big.Int, w, l uint) []int32 {
// 	if n.Sign() <= 0 || n.Bit(0) == 0 {
// 		panic("n must be non-zero, odd, and positive")
// 	}
// 	if w <= 1 || w >= 32 {
// 		panic("Verify that 1 < w < 32")
// 	}
// 	if uint(n.BitLen()) > l {
// 		panic("n is too big to fit in l digits")
// 	}
// 	lenN := (l + (w - 1) - 1) / (w - 1) // ceil(l/(w-1))
// 	L := make([]int32, lenN+1)
// 	var k, v big.Int
// 	k.Set(n)

// 	var i uint
// 	for i = 0; i < lenN; i++ {
// 		words := k.Bits()
// 		value := int32(words[0] & ((1 << w) - 1))
// 		value -= int32(1) << (w - 1)
// 		L[i] = value
// 		v.SetInt64(int64(value))
// 		k.Sub(&k, &v)
// 		k.Rsh(&k, w-1)
// 	}
// 	L[i] = int32(k.Int64())
// 	return L
// }

// // OmegaNAF obtains the window-w Non-Adjacent Form of a positive number n and
// // 1 < w < 32. The returned slice L holds n = sum( L[i]*2^i ).
// //
// // Reference:
// //   - Alg.9 "Efficient arithmetic on Koblitz curves" by Solinas.
// //     http://doi.org/10.1023/A:1008306223194
// func OmegaNAF(n *big.Int, w uint) (L []int32) {
// 	if n.Sign() < 0 {
// 		panic("n must be positive")
// 	}
// 	if w <= 1 || w >= 32 {
// 		panic("Verify that 1 < w < 32")
// 	}

// 	L = make([]int32, n.BitLen()+1)
// 	var k, v big.Int
// 	k.Set(n)

// 	i := 0
// 	for ; k.Sign() > 0; i++ {
// 		value := int32(0)
// 		if k.Bit(0) == 1 {
// 			words := k.Bits()
// 			value = int32(words[0] & ((1 << w) - 1))
// 			if value >= (int32(1) << (w - 1)) {
// 				value -= int32(1) << w
// 			}
// 			v.SetInt64(int64(value))
// 			k.Sub(&k, &v)
// 		}
// 		L[i] = value
// 		k.Rsh(&k, 1)
// 	}
// 	return L[:i]
// }

// // BytesLe2BigInt converts a little-endian slice x into a big-endian
// // math/big.Int.
// func BytesLe2BigInt(x []byte) *big.Int {
// 	n := len(x)
// 	b := new(big.Int)
// 	if len(x) > 0 {
// 		y := make([]byte, n)
// 		for i := 0; i < n; i++ {
// 			y[n-1-i] = x[i]
// 		}
// 		b.SetBytes(y)
// 	}
// 	return b
// }

// // BytesBe2Uint64Le converts a big-endian slice x to a little-endian slice of uint64.
// func BytesBe2Uint64Le(x []byte) []uint64 {
// 	l := len(x)
// 	z := make([]uint64, (l+7)/8)
// 	blocks := l / 8
// 	for i := 0; i < blocks; i++ {
// 		z[i] = binary.BigEndianUint64(x[l-8*(i+1):])
// 	}
// 	remBytes := l % 8
// 	for i := 0; i < remBytes; i++ {
// 		z[blocks] |= uint64(x[l-1-8*blocks-i]) << uint(8*i)
// 	}
// 	return z
// }

// // BigInt2BytesLe stores a positive big.Int number x into a little-endian slice z.
// // The slice is modified if the bitlength of x <= 8*len(z) (padding with zeros).
// // If x does not fit in the slice or is negative, z is not modified.
// func BigInt2BytesLe(z []byte, x *big.Int) {
// 	xLen := (x.BitLen() + 7) >> 3
// 	zLen := len(z)
// 	if zLen >= xLen && x.Sign() >= 0 {
// 		y := x.Bytes()
// 		for i := 0; i < xLen; i++ {
// 			z[i] = y[xLen-1-i]
// 		}
// 		for i := xLen; i < zLen; i++ {
// 			z[i] = 0
// 		}
// 	}
// }

// // Uint64Le2BigInt converts a little-endian slice x into a big number.
// func Uint64Le2BigInt(x []uint64) *big.Int {
// 	n := len(x)
// 	b := new(big.Int)
// 	var bi big.Int
// 	for i := n - 1; i >= 0; i-- {
// 		bi.SetUint64(x[i])
// 		b.Lsh(b, 64)
// 		b.Add(b, &bi)
// 	}
// 	return b
// }

// // Uint64Le2BytesLe converts a little-endian slice x to a little-endian slice of bytes.
// func Uint64Le2BytesLe(x []uint64) []byte {
// 	b := make([]byte, 8*len(x))
// 	n := len(x)
// 	for i := 0; i < n; i++ {
// 		binary.LittleEndianPutUint64(b[i*8:], x[i])
// 	}
// 	return b
// }

// // Uint64Le2BytesBe converts a little-endian slice x to a big-endian slice of bytes.
// func Uint64Le2BytesBe(x []uint64) []byte {
// 	b := make([]byte, 8*len(x))
// 	n := len(x)
// 	for i := 0; i < n; i++ {
// 		binary.BigEndianPutUint64(b[i*8:], x[n-1-i])
// 	}
// 	return b
// }

func eltcmov(x, y Elt, n uint) {
 	cmovGeneric(x, y, n)
}

func eltcswap(x, y Elt, n uint) {
 	cswapGeneric(x, y, n)
}

func eltfpadd(z, x, y Elt) {
 	addGeneric(z, x, y)
}

func eltfpsub(z, x, y Elt) {
	subGeneric(z, x, y)
}

func eltaddsub(x, y Elt) {
  addsubGeneric(x, y)
}

func eltmul(z, x, y Elt) {
 	mulGeneric(z, x, y)
}

func eltsqr(z, x Elt) {
 	sqrGeneric(z, x)
}

// // Power is a valid exponent produced by the MLSBSet encoding algorithm.
// type Power struct {
// 	set Encoder // parameters of code.
// 	s   []int32 // set of signs.
// 	b   []int32 // set of digits.
// 	c   int     // carry is {0,1}.
// }

// // Exp is calculates x^k, where x is a predetermined element of a group G.
// func PowerExp(p *Power, G groupMLSB) EltG {
// 	a, b := GroupIdentity(G), GroupNewEltP(G)
// 	s := p.set
// 	sp := s.p
// 	for e := int(sp.E - 1); e >= 0; e-- {
// 		GroupSqr(G, a)
// 		for v := uint(0); v < sp.V; v++ {
// 			sgnElt, idElt := p.Digit(v, uint(e))
// 			GroupLookup(b, v, sgnElt, idElt)
// 			GroupMul(a, b)
// 		}
// 	}
// 	if IsExtended(s) && p.c == 1 {
// 		GroupMLSBMul(G, a, GroupExtendedEltP(G))
// 	}
// 	return a
// }

// // Digit returns the (v,e)-th digit and its sign.
// func PowerDigit(p *Power, v, e uint) (sgn, dig int32) {
// 	sgn = p.bit(0, v, e)
// 	dig = 0
// 	s := p.set
// 	sp := s.p
// 	for i := sp.W - 1; i > 0; i-- {
// 		dig = 2*dig + powerbit(p, i, v, e)
// 	}
// 	mask := dig >> 31
// 	dig = (dig + mask) ^ mask
// 	return sgn, dig
// }

// // bit returns the (w,v,e)-th bit of the code.
// func powerbit(p *Power, w, v, e uint) int32 {
// 	s := p.set
// 	sp := s.p
// 	if !(w < sp.W &&
// 		v < sp.V &&
// 		e < sp.E) {
// 		return 0
// 	}
// 	if w == 0 {
// 		return p.s[sp.E*v+e]
// 	}
// 	return p.b[sp.D*(w-1)+sp.E*v+e]
// }
